[
{
  "name": "Array",
  "comment": "A library for fast immutable arrays. The elements in an array must have the\nsame type. The arrays are implemented in Relaxed Radix Balanced-Trees for fast\nreads, updates, and appends.\n\n# Creating Arrays\n@docs empty, repeat, initialize, fromList\n\n# Basics\n@docs length, push, append\n\n# Get and Set\n@docs get, set\n\n# Taking Arrays Apart\n@docs slice, toList, toIndexedList\n\n# Mapping, Filtering, and Folding\n@docs map, indexedMap, filter, foldl, foldr",
  "aliases": [],
  "types": [
    {
      "name": "Array",
      "comment": "",
      "args": [
        "a"
      ],
      "cases": [
        [
          "Array",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "append",
      "comment": "Append two arrays to a new one.\n\n    append (repeat 2 42) (repeat 3 81) == fromList [42,42,81,81,81]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Array"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "empty",
      "comment": "Return an empty array.\n\n    length empty == 0",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Array"
        },
        "args": [
          {
            "tag": "var",
            "name": "a"
          }
        ]
      }
    },
    {
      "name": "filter",
      "comment": "Keep only elements that satisfy the predicate:\n\n    filter isEven (fromList [1..6]) == (fromList [2,4,6])",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "foldl",
      "comment": "Reduce an array from the left. Read `foldl` as &ldquo;fold from the left&rdquo;.\n\n    foldl (::) [] (fromList [1,2,3]) == [3,2,1]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Array"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "foldr",
      "comment": "Reduce an array from the right. Read `foldr` as &ldquo;fold from the right&rdquo;.\n\n    foldr (+) 0 (repeat 3 5) == 15",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Array"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "fromList",
      "comment": "Create an array from a list.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Array"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "get",
      "comment": "Return Just the element at the index or Nothing if the index is out of range.\n\n    get  0 (fromList [0,1,2]) == Just 0\n    get  2 (fromList [0,1,2]) == Just 2\n    get  5 (fromList [0,1,2]) == Nothing\n    get -1 (fromList [0,1,2]) == Nothing\n\nThe `(?)` operator from the `Maybe` library makes it easy to give a default\nvalue.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "indexedMap",
      "comment": "Apply a function on every element with its index as first argument.\n\n    indexedMap (*) (fromList [5,5,5]) == fromList [0,5,10]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "initialize",
      "comment": "Initialize an array. `initialize n f` creates an array of length `n` with\nthe element at index `i` initialized to the result of `(f i)`.\n\n    initialize 4 identity    == fromList [0,1,2,3]\n    initialize 4 (\\n -\u003e n*n) == fromList [0,1,4,9]\n    initialize 4 (always 0)  == fromList [0,0,0,0]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Int"
            },
            "out": {
              "tag": "var",
              "name": "a"
            }
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "length",
      "comment": "Return the length of an array.\n\n    length (fromList [1,2,3]) == 3",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Array"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "map",
      "comment": "Apply a function on every element in an array.\n\n    map sqrt (fromList [1,4,9]) == fromList [1,2,3]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "push",
      "comment": "Push an element to the end of an array.\n\n    push 3 (fromList [1,2]) == fromList [1,2,3]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "repeat",
      "comment": "Creates an array with a given length, filled with a default element.\n\n    repeat 5 0     == fromList [0,0,0,0,0]\n    repeat 3 \"cat\" == fromList [\"cat\",\"cat\",\"cat\"]\n\nNotice that `repeat 3 x` is the same as `initialize 3 (always x)`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Array"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "set",
      "comment": "Set the element at a particular index. Returns an updated array.\nIf the index is out of range, the array is unaltered.\n\n    set 1 7 (fromList [1,2,3]) == fromList [1,7,3]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Array"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Array"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "slice",
      "comment": "Get a sub-section of an array: `(slice start end array)`. The `start` is a\nzero-based index where we will start our slice. The `end` is a zero-based index\nthat indicates the end of the slice. The slice extracts up to but not including\n`end`.\n\n    slice  0  3 (fromList [0,1,2,3,4]) == fromList [0,1,2]\n    slice  1  4 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n\nBoth the `start` and `end` indexes can be negative, indicating an offset from\nthe end of the array.\n\n    slice  1 -1 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n    slice -2  5 (fromList [0,1,2,3,4]) == fromList [3,4]\n\nThis makes it pretty easy to `pop` the last element off of an array: `slice 0 -1 array`",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Array"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Array"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "toIndexedList",
      "comment": "Create an indexed list from an array. Each element of the array will be\npaired with its index.\n\n    toIndexedList (fromList [\"cat\",\"dog\"]) == [(0,\"cat\"), (1,\"dog\")]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Array"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Int"
                },
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "toList",
      "comment": "Create a list of elements from an array.\n\n    toList (fromList [3,5,8]) == [3,5,8]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Array"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    }
  ]
}
,
{
  "name": "Basics",
  "comment": "Tons of useful functions that get imported by default.\n\n# Equality\n@docs (==), (/=)\n\n# Comparison\n\nThese functions only work on `comparable` types. This includes numbers,\ncharacters, strings, lists of comparable things, and tuples of comparable\nthings. Note that tuples with 7 or more elements are not comparable; why\nare your tuples so big?\n\n@docs (\u003c), (\u003e), (\u003c=), (\u003e=), max, min, Order, compare\n\n# Booleans\n@docs not, (&&), (||), xor, otherwise\n\n# Mathematics\n@docs (+), (-), (*), (/), (^), (//), rem, (%), negate, abs, sqrt, clamp, logBase, e\n\n# Trigonometry\n@docs pi, cos, sin, tan, acos, asin, atan, atan2\n\n# Number Conversions\n@docs round, floor, ceiling, truncate, toFloat\n\n# Angle Conversions\nAll angle conversions result in &ldquo;standard Elm angles&rdquo;\nwhich happen to be radians.\n\n@docs degrees, radians, turns\n\n# Polar Coordinates\n@docs toPolar, fromPolar\n\n# Floating Point Checks\n@docs isNaN, isInfinite\n\n# Strings and Lists\n@docs toString, (++)\n\n# Tuples\n@docs fst, snd\n\n# Higher-Order Helpers\n@docs identity, always, (\u003c|), (|\u003e), (\u003c\u003c), (\u003e\u003e), flip, curry, uncurry",
  "aliases": [],
  "types": [
    {
      "name": "Order",
      "comment": "Represents the relative ordering of two things.\nThe relations are less than, equal to, and greater than.",
      "args": [],
      "cases": [
        [
          "LT",
          []
        ],
        [
          "EQ",
          []
        ],
        [
          "GT",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "%",
      "comment": "Perform [modular arithmetic](http://en.wikipedia.org/wiki/Modular_arithmetic).\n\n     7 % 2 == 1\n    -1 % 4 == 3",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      },
      "associativity": "left",
      "precedence": 7
    },
    {
      "name": "&&",
      "comment": "The logical AND operator. `True` if both inputs are `True`.\nThis operator short-circuits to `False` if the first argument is `False`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Bool"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Bool"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "right",
      "precedence": 3
    },
    {
      "name": "*",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "number"
          },
          "out": {
            "tag": "var",
            "name": "number"
          }
        }
      },
      "associativity": "left",
      "precedence": 7
    },
    {
      "name": "+",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "number"
          },
          "out": {
            "tag": "var",
            "name": "number"
          }
        }
      },
      "associativity": "left",
      "precedence": 6
    },
    {
      "name": "++",
      "comment": "Put two appendable things together. This includes strings, lists, and text.\n\n    \"hello\" ++ \"world\" == \"helloworld\"\n    [1,1,2] ++ [3,5,8] == [1,1,2,3,5,8]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "appendable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "appendable"
          },
          "out": {
            "tag": "var",
            "name": "appendable"
          }
        }
      },
      "associativity": "right",
      "precedence": 5
    },
    {
      "name": "-",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "number"
          },
          "out": {
            "tag": "var",
            "name": "number"
          }
        }
      },
      "associativity": "left",
      "precedence": 6
    },
    {
      "name": "/",
      "comment": "Floating point division.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Float"
          }
        }
      },
      "associativity": "left",
      "precedence": 7
    },
    {
      "name": "//",
      "comment": "Integer division. The remainder is discarded.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      },
      "associativity": "left",
      "precedence": 7
    },
    {
      "name": "/=",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "non",
      "precedence": 4
    },
    {
      "name": "\u003c",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "non",
      "precedence": 4
    },
    {
      "name": "\u003c\u003c",
      "comment": "Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    not \u003c\u003c isEven \u003c\u003c sqrt\n\nYou can think of this operator as equivalent to the following:\n\n    (g \u003c\u003c f)  ==  (\\x -\u003e g (f x))\n\nSo our example expands out to something like this:\n\n    \\n -\u003e not (isEven (sqrt n))",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "var",
            "name": "c"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "c"
            }
          }
        }
      },
      "associativity": "right",
      "precedence": 9
    },
    {
      "name": "\u003c=",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "non",
      "precedence": 4
    },
    {
      "name": "\u003c|",
      "comment": "Backward function application `f \u003c| x == f x`. This function is useful for\navoiding parenthesis. Consider the following code to create a text element:\n\n    leftAligned (monospace (fromString \"code\"))\n\nThis can also be written as:\n\n    leftAligned \u003c\u003c monospace \u003c| fromString \"code\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        }
      },
      "associativity": "right",
      "precedence": 0
    },
    {
      "name": "==",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "non",
      "precedence": 4
    },
    {
      "name": "\u003e",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "non",
      "precedence": 4
    },
    {
      "name": "\u003e=",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "non",
      "precedence": 4
    },
    {
      "name": "\u003e\u003e",
      "comment": "Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    sqrt \u003e\u003e isEven \u003e\u003e not\n\nThis direction of function composition seems less pleasant than `(\u003c\u003c)` which\nreads nicely in expressions like: `filter (not \u003c\u003c isRegistered) students`",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "c"
            }
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "c"
            }
          }
        }
      },
      "associativity": "left",
      "precedence": 9
    },
    {
      "name": "^",
      "comment": "Exponentiation\n\n    3^2 == 9",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "number"
          },
          "out": {
            "tag": "var",
            "name": "number"
          }
        }
      },
      "associativity": "left",
      "precedence": 8
    },
    {
      "name": "abs",
      "comment": "Take the absolute value of a number.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "var",
          "name": "number"
        }
      }
    },
    {
      "name": "acos",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "always",
      "comment": "Create a [constant function](http://en.wikipedia.org/wiki/Constant_function),\na function that *always* returns the same value regardless of what input you give.\nIt is defined as:\n\n    always a b = a\n\nIt totally ignores the second argument, so `always 42` is a function that always\nreturns 42. When you are dealing with higher-order functions, this comes in\nhandy more often than you might expect. For example, creating a zeroed out list\nof length ten would be:\n\n    map (always 0) [0..9]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "var",
            "name": "a"
          }
        }
      }
    },
    {
      "name": "asin",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "atan",
      "comment": "You probably do not want to use this. It takes `(y/x)` as the\nargument, so there is no way to know whether the negative signs comes from\nthe `y` or `x`. Thus, the resulting angle is always between &pi;/2 and -&pi;/2\n(in quadrants I and IV). You probably want to use `atan2` instead.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "atan2",
      "comment": "This helps you find the angle of a cartesian coordinate.\nYou will almost certainly want to use this instead of `atan`.\nSo `atan2 y x` computes *atan(y/x)* but also keeps track of which\nquadrant the angle should really be in. The result will be between\n&pi; and -&pi;, giving you the full range of angles.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Float"
          }
        }
      }
    },
    {
      "name": "ceiling",
      "comment": "Ceiling function, rounding up.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "clamp",
      "comment": "Clamps a number within a given range. With the expression\n`clamp 100 200 x` the results are as follows:\n\n    100     if x \u003c 100\n     x      if 100 \u003c= x \u003c 200\n    200     if 200 \u003c= x",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "number"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "number"
            },
            "out": {
              "tag": "var",
              "name": "number"
            }
          }
        }
      }
    },
    {
      "name": "compare",
      "comment": "Compare any two comparable values. Comparable values include `String`, `Char`,\n`Int`, `Float`, `Time`, or a list or tuple containing comparable values.\nThese are also the only values that work as `Dict` keys or `Set` members.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "type",
            "name": "Order"
          }
        }
      }
    },
    {
      "name": "cos",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "curry",
      "comment": "Change how arguments are passed to a function.\nThis splits paired arguments into two separate arguments.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              },
              {
                "tag": "var",
                "name": "b"
              }
            ]
          },
          "out": {
            "tag": "var",
            "name": "c"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "c"
            }
          }
        }
      }
    },
    {
      "name": "degrees",
      "comment": "Convert degrees to standard Elm angles (radians).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "e",
      "comment": "An approximation of e.",
      "type": {
        "tag": "type",
        "name": "Float"
      }
    },
    {
      "name": "flip",
      "comment": "Flip the order of the first two arguments to a function.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "c"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "c"
            }
          }
        }
      }
    },
    {
      "name": "floor",
      "comment": "Floor function, rounding down.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "fromPolar",
      "comment": "Convert polar coordinates (r,&theta;) to cartesian coordinates (x,y).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        }
      }
    },
    {
      "name": "fst",
      "comment": "Given a 2-tuple, returns the first value.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            },
            {
              "tag": "var",
              "name": "b"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "a"
        }
      }
    },
    {
      "name": "identity",
      "comment": "Given a value, returns exactly the same value. This is called\n[the identity function](http://en.wikipedia.org/wiki/Identity_function).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "var",
          "name": "a"
        }
      }
    },
    {
      "name": "isInfinite",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "isNaN",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "logBase",
      "comment": "Calculate the logarithm of a number with a given base.\n\n    logBase 10 100 == 2\n    logBase 2 256 == 8",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Float"
          }
        }
      }
    },
    {
      "name": "max",
      "comment": "Find the larger of two comparables.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "var",
            "name": "comparable"
          }
        }
      }
    },
    {
      "name": "min",
      "comment": "Find the smaller of two comparables.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "var",
            "name": "comparable"
          }
        }
      }
    },
    {
      "name": "negate",
      "comment": "Negate a number.\n\n    negate 42 == -42\n    negate -42 == 42\n    negate 0 == 0",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "var",
          "name": "number"
        }
      }
    },
    {
      "name": "not",
      "comment": "Negate a boolean value.\n\n    not True == False\n    not False == True",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Bool"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "otherwise",
      "comment": "Equal to `True`. Useful as the last case of a multi-way-if.",
      "type": {
        "tag": "type",
        "name": "Bool"
      }
    },
    {
      "name": "pi",
      "comment": "An approximation of pi.",
      "type": {
        "tag": "type",
        "name": "Float"
      }
    },
    {
      "name": "radians",
      "comment": "Convert radians to standard Elm angles (radians).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "rem",
      "comment": "Find the remainder after dividing one number by another.\n\n     7 `rem` 2 == 1\n    -1 `rem` 4 == -1",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      },
      "associativity": "left",
      "precedence": 7
    },
    {
      "name": "round",
      "comment": "Round a number to the nearest integer.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "sin",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "snd",
      "comment": "Given a 2-tuple, returns the second value.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            },
            {
              "tag": "var",
              "name": "b"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "b"
        }
      }
    },
    {
      "name": "sqrt",
      "comment": "Take the square root of a number.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "tan",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "toFloat",
      "comment": "Convert an integer into a float.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "toPolar",
      "comment": "Convert cartesian coordinates (x,y) to polar coordinates (r,&theta;).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        }
      }
    },
    {
      "name": "toString",
      "comment": "Turn any kind of value into a string. When you view the resulting string\nwith `Text.fromString` it should look just like the value it came from.\n\n    toString 42 == \"42\"\n    toString [1,2] == \"[1,2]\"\n    toString \"he said, \\\"hi\\\"\" == \"\\\"he said, \\\\\\\"hi\\\\\\\"\\\"\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "truncate",
      "comment": "Truncate a number, rounding towards zero.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "turns",
      "comment": "Convert turns to standard Elm angles (radians).\nOne turn is equal to 360&deg;.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "uncurry",
      "comment": "Change how arguments are passed to a function.\nThis combines two arguments into a single pair.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "c"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              },
              {
                "tag": "var",
                "name": "b"
              }
            ]
          },
          "out": {
            "tag": "var",
            "name": "c"
          }
        }
      }
    },
    {
      "name": "xor",
      "comment": "The exclusive-or operator. `True` if exactly one input is `True`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Bool"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Bool"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "|\u003e",
      "comment": "Forward function application `x |\u003e f == f x`. This function is useful\nfor avoiding parenthesis and writing code in a more natural way.\nConsider the following code to create a pentagon:\n\n    scale 2 (move (10,10) (filled blue (ngon 5 30)))\n\nThis can also be written as:\n\n    ngon 5 30\n      |\u003e filled blue\n      |\u003e move (10,10)\n      |\u003e scale 2",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        }
      },
      "associativity": "left",
      "precedence": 0
    },
    {
      "name": "||",
      "comment": "The logical OR operator. `True` if one or both inputs are `True`.\nThis operator short-circuits to `True` if the first argument is `True`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Bool"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Bool"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      "associativity": "right",
      "precedence": 2
    }
  ]
}
,
{
  "name": "Bitwise",
  "comment": "Library for [bitwise operations](http://en.wikipedia.org/wiki/Bitwise_operation).\n\n# Basic Operations\n\n@docs and, or, xor, complement\n\n# Bit Shifts\n\n@docs shiftLeft, shiftRight, shiftRightLogical",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "and",
      "comment": "Bitwise AND",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      }
    },
    {
      "name": "complement",
      "comment": "Flip each bit individually, often called bitwise NOT",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "or",
      "comment": "Bitwise OR",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      }
    },
    {
      "name": "shiftLeft",
      "comment": "Shift bits to the left by a given offset, filling new bits with zeros.\nThis can be used to multiply numbers by powers of two.\n\n    8 `shiftLeft` 1 == 16\n    8 `shiftLeft` 2 == 32",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      }
    },
    {
      "name": "shiftRight",
      "comment": "Shift bits to the right by a given offset, filling new bits with\nwhatever is the topmost bit. This can be used to divide numbers by powers of two.\n\n     32 `shiftRight` 1 == 16\n     32 `shiftRight` 2 == 8\n    -32 `shiftRight` 1 == -16\n\nThis is called an [arithmatic right\nshift](http://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift),\noften written (\u003e\u003e), and sometimes called a sign-propagating\nright shift because it fills empty spots with copies of the highest bit.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      }
    },
    {
      "name": "shiftRightLogical",
      "comment": "Shift bits to the right by a given offset, filling new bits with\nzeros.\n\n     32 `shiftRightLogical` 1 == 16\n     32 `shiftRightLogical` 2 == 8\n    -32 `shiftRightLogical` 1 == 2147483632\n\nThis is called an [logical right\nshift](http://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift), often written (\u003e\u003e\u003e),\nand sometimes called a zero-fill right shift because it fills empty spots\nwith zeros.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      }
    },
    {
      "name": "xor",
      "comment": "Bitwise XOR",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Int"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Char",
  "comment": "Functions for working with characters. Character literals are enclosed in\n`'a'` pair of single quotes.\n\n# Classification\n@docs isUpper, isLower, isDigit, isOctDigit, isHexDigit\n\n# Conversion\n@docs toUpper, toLower, toLocaleUpper, toLocaleLower, toCode, fromCode",
  "aliases": [
    {
      "name": "KeyCode",
      "comment": "",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Int"
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "fromCode",
      "comment": "Convert from unicode.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "KeyCode"
        },
        "out": {
          "tag": "type",
          "name": "Char"
        }
      }
    },
    {
      "name": "isDigit",
      "comment": "True for ASCII digits `[0-9]`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "isHexDigit",
      "comment": "True for ASCII hexadecimal digits `[0-9a-fA-F]`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "isLower",
      "comment": "True for lower case letters.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "isOctDigit",
      "comment": "True for ASCII octal digits `[0-7]`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "isUpper",
      "comment": "True for upper case letters.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "toCode",
      "comment": "Convert to unicode. Used with the `Keyboard` library, which expects the\ninput to be uppercase.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "KeyCode"
        }
      }
    },
    {
      "name": "toLocaleLower",
      "comment": "Convert to lower case, according to any locale-specific case mappings.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Char"
        }
      }
    },
    {
      "name": "toLocaleUpper",
      "comment": "Convert to upper case, according to any locale-specific case mappings.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Char"
        }
      }
    },
    {
      "name": "toLower",
      "comment": "Convert to lower case.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Char"
        }
      }
    },
    {
      "name": "toUpper",
      "comment": "Convert to upper case.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "Char"
        }
      }
    }
  ]
}
,
{
  "name": "Color",
  "comment": "Library for working with colors. Includes\n[RGB](https://en.wikipedia.org/wiki/RGB_color_model) and\n[HSL](http://en.wikipedia.org/wiki/HSL_and_HSV) creation, gradients, and\nbuilt-in names.\n\n# Creation\n@docs rgb, rgba, hsl, hsla, greyscale, grayscale, complement\n\n# Gradients\n@docs linear, radial\n\n# Extracting Colors\n@docs toRgb, toHsl\n\n# Built-in Colors\nThese colors come from the [Tango\npalette](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines)\nwhich provides aesthetically reasonable defaults for colors. Each color also\ncomes with a light and dark version.\n\n### Standard\n@docs red, orange, yellow, green, blue, purple, brown\n\n### Light\n@docs lightRed, lightOrange, lightYellow, lightGreen, lightBlue, lightPurple, lightBrown\n\n### Dark\n@docs darkRed, darkOrange, darkYellow, darkGreen, darkBlue, darkPurple, darkBrown\n\n### Eight Shades of Grey\nThese colors are a compatible series of shades of grey, fitting nicely\nwith the Tango palette.\n@docs white, lightGrey, grey, darkGrey, lightCharcoal, charcoal, darkCharcoal, black\n\nThese are identical to the *grey* versions. It seems the spelling is regional, but\nthat has never helped me remember which one I should be writing.\n@docs lightGray, gray, darkGray",
  "aliases": [],
  "types": [
    {
      "name": "Gradient",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Linear",
          [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "_Tuple2"
                  },
                  "args": [
                    {
                      "tag": "type",
                      "name": "Float"
                    },
                    {
                      "tag": "type",
                      "name": "Color"
                    }
                  ]
                }
              ]
            }
          ]
        ],
        [
          "Radial",
          [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            },
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            },
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "_Tuple2"
                  },
                  "args": [
                    {
                      "tag": "type",
                      "name": "Float"
                    },
                    {
                      "tag": "type",
                      "name": "Color"
                    }
                  ]
                }
              ]
            }
          ]
        ]
      ]
    },
    {
      "name": "Color",
      "comment": "",
      "args": [],
      "cases": [
        [
          "RGBA",
          [
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        ],
        [
          "HSLA",
          [
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "black",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "blue",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "brown",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "charcoal",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "complement",
      "comment": "Produce a &ldquo;complementary color&rdquo;. The two colors will\naccent each other. This is the same as rotating the hue by 180&deg;.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "type",
          "name": "Color"
        }
      }
    },
    {
      "name": "darkBlue",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkBrown",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkCharcoal",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkGray",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkGreen",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkGrey",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkOrange",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkPurple",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkRed",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "darkYellow",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "fmod",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Float"
          }
        }
      }
    },
    {
      "name": "gray",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "grayscale",
      "comment": "Produce a gray based on the input. 0 is white, 1 is black.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Color"
        }
      }
    },
    {
      "name": "green",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "grey",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "greyscale",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Color"
        }
      }
    },
    {
      "name": "hsl",
      "comment": "Create [HSL colors](http://en.wikipedia.org/wiki/HSL_and_HSV). This gives\nyou access to colors more like a color wheel, where all hues are aranged in a\ncircle that you specify with standard Elm angles (radians).\n\n    red   = hsl (degrees   0) 1 0.5\n    green = hsl (degrees 120) 1 0.5\n    blue  = hsl (degrees 240) 1 0.5\n\n    pastelRed = hsl (degrees 0) 0.7 0.7\n\nTo cycle through all colors, just cycle through degrees. The saturation level\nis how vibrant the color is, like a dial between grey and bright colors. The\nlightness level is a dial between white and black.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Float"
            },
            "out": {
              "tag": "type",
              "name": "Color"
            }
          }
        }
      }
    },
    {
      "name": "hslToRgb",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Float"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple3"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "hsla",
      "comment": "Create [HSL colors](http://en.wikipedia.org/wiki/HSL_and_HSV)\nwith an alpha component for transparency.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Float"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Float"
              },
              "out": {
                "tag": "type",
                "name": "Color"
              }
            }
          }
        }
      }
    },
    {
      "name": "lightBlue",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightBrown",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightCharcoal",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightGray",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightGreen",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightGrey",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightOrange",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightPurple",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightRed",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "lightYellow",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "linear",
      "comment": "Create a linear gradient. Takes a start and end point and then a series of\n&ldquo;color stops&rdquo; that indicate how to interpolate between the start and\nend points. See [this example](http://elm-lang.org/edit/examples/Elements/LinearGradient.elm) for a\nmore visual explanation.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "var",
              "name": "number"
            },
            {
              "tag": "var",
              "name": "number"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "var",
                "name": "number"
              },
              {
                "tag": "var",
                "name": "number"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "_Tuple2"
                  },
                  "args": [
                    {
                      "tag": "type",
                      "name": "Float"
                    },
                    {
                      "tag": "type",
                      "name": "Color"
                    }
                  ]
                }
              ]
            },
            "out": {
              "tag": "type",
              "name": "Gradient"
            }
          }
        }
      }
    },
    {
      "name": "orange",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "purple",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "radial",
      "comment": "Create a radial gradient. First takes a start point and inner radius.  Then\ntakes an end point and outer radius. It then takes a series of &ldquo;color\nstops&rdquo; that indicate how to interpolate between the inner and outer\ncircles. See [this example](http://elm-lang.org/edit/examples/Elements/RadialGradient.elm) for a\nmore visual explanation.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "var",
              "name": "number"
            },
            {
              "tag": "var",
              "name": "number"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "number"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "number"
                },
                {
                  "tag": "var",
                  "name": "number"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "number"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "List"
                  },
                  "args": [
                    {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "_Tuple2"
                      },
                      "args": [
                        {
                          "tag": "type",
                          "name": "Float"
                        },
                        {
                          "tag": "type",
                          "name": "Color"
                        }
                      ]
                    }
                  ]
                },
                "out": {
                  "tag": "type",
                  "name": "Gradient"
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "red",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "rgb",
      "comment": "Create RGB colors from numbers between 0 and 255 inclusive.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Int"
            },
            "out": {
              "tag": "type",
              "name": "Color"
            }
          }
        }
      }
    },
    {
      "name": "rgbToHsl",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Int"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple3"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "rgba",
      "comment": "Create RGB colors with an alpha component for transparency.\nThe alpha component is specified with numbers between 0 and 1.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Int"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Float"
              },
              "out": {
                "tag": "type",
                "name": "Color"
              }
            }
          }
        }
      }
    },
    {
      "name": "toHsl",
      "comment": "Extract the components of a color in the HSL format.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "record",
          "extension": null,
          "fields": [
            [
              "hue",
              {
                "tag": "type",
                "name": "Float"
              }
            ],
            [
              "saturation",
              {
                "tag": "type",
                "name": "Float"
              }
            ],
            [
              "lightness",
              {
                "tag": "type",
                "name": "Float"
              }
            ],
            [
              "alpha",
              {
                "tag": "type",
                "name": "Float"
              }
            ]
          ]
        }
      }
    },
    {
      "name": "toRgb",
      "comment": "Extract the components of a color in the RGB format.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "record",
          "extension": null,
          "fields": [
            [
              "red",
              {
                "tag": "type",
                "name": "Int"
              }
            ],
            [
              "green",
              {
                "tag": "type",
                "name": "Int"
              }
            ],
            [
              "blue",
              {
                "tag": "type",
                "name": "Int"
              }
            ],
            [
              "alpha",
              {
                "tag": "type",
                "name": "Float"
              }
            ]
          ]
        }
      }
    },
    {
      "name": "white",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    },
    {
      "name": "yellow",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Color"
      }
    }
  ]
}
,
{
  "name": "Date",
  "comment": "Library for working with dates. Email the mailing list if you encounter\nissues with internationalization or locale formatting.\n\n# Conversions\n@docs fromString, toTime, fromTime\n\n# Extractions\n@docs year, month, Month, day, dayOfWeek, Day, hour, minute, second",
  "aliases": [],
  "types": [
    {
      "name": "Month",
      "comment": "Represents the month of the year.",
      "args": [],
      "cases": [
        [
          "Jan",
          []
        ],
        [
          "Feb",
          []
        ],
        [
          "Mar",
          []
        ],
        [
          "Apr",
          []
        ],
        [
          "May",
          []
        ],
        [
          "Jun",
          []
        ],
        [
          "Jul",
          []
        ],
        [
          "Aug",
          []
        ],
        [
          "Sep",
          []
        ],
        [
          "Oct",
          []
        ],
        [
          "Nov",
          []
        ],
        [
          "Dec",
          []
        ]
      ]
    },
    {
      "name": "Day",
      "comment": "Represents the days of the week.",
      "args": [],
      "cases": [
        [
          "Mon",
          []
        ],
        [
          "Tue",
          []
        ],
        [
          "Wed",
          []
        ],
        [
          "Thu",
          []
        ],
        [
          "Fri",
          []
        ],
        [
          "Sat",
          []
        ],
        [
          "Sun",
          []
        ]
      ]
    },
    {
      "name": "Date",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Date",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "day",
      "comment": "Extract the day of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `23`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "dayOfWeek",
      "comment": "Extract the day of the week for a given date. Given the date 23 June\n1990 at 11:45AM this returns the Day `Thu` as defined below.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Day"
        }
      }
    },
    {
      "name": "fromString",
      "comment": "Attempt to read a date from a string.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Result"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            },
            {
              "tag": "type",
              "name": "Date"
            }
          ]
        }
      }
    },
    {
      "name": "fromTime",
      "comment": "Take a UNIX time and convert it to a `Date`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "type",
          "name": "Date"
        }
      }
    },
    {
      "name": "hour",
      "comment": "Extract the hour of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `11`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "minute",
      "comment": "Extract the minute of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `45`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "month",
      "comment": "Extract the month of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the Month `Jun` as defined below.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Month"
        }
      }
    },
    {
      "name": "second",
      "comment": "Extract the second of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `0`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "toTime",
      "comment": "Convert a date into a time since midnight (UTC) of 1 January 1990 (i.e.\n[UNIX time](http://en.wikipedia.org/wiki/Unix_time)). Given the date 23 June\n1990 at 11:45AM this returns the corresponding time.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Time"
        }
      }
    },
    {
      "name": "year",
      "comment": "Extract the year of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `1990`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Date"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    }
  ]
}
,
{
  "name": "Debug",
  "comment": "This library is for investigating bugs or performance problems. It should\n*not* be used in production code.\n\n# Console Debugging\n@docs log, crash\n\n# Time-Travel Debugging\n@docs watch, watchSummary, trace",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "crash",
      "comment": "Crash the program with an error message. This is an uncatchable error,\nintended for code that is soon-to-be-implemented. For example, if you are\nworking with a large ADT and have partially completed a case expression, it may\nmake sense to do this:\n\n    data Entity = Ship | Fish | Captain | Seagull\n\n    drawEntity entity =\n        case entity of\n          Ship -\u003e ...\n          Fish -\u003e ...\n          _ -\u003e Debug.crash (\"drawEntity not implemented for \" ++ toString entity ++ \" yet!\")\n\nNote that incomplete pattern matches are *very* bad practice! They are one of\nthe very few ways to crash an Elm program, and they are completely avoidable.\nProduction code should not have incomplete pattern matches!\n\n**Use this if** you want to do some testing while you are partway through\nwriting a function.\n\n**Do not use this if** you want to do some typical try-catch exception handling.\nUse the `Maybe` or `Either` libraries instead.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "var",
          "name": "a"
        }
      }
    },
    {
      "name": "log",
      "comment": "Log a tagged value on the developer console, and then return the value.\n\n    1 + log \"number\" 1        -- equals 2, logs \"number: 1\"\n    length (log \"start\" [])   -- equals 0, logs \"start: []\"\n\nNotice that `log` is not a pure function! It should *only* be used for\ninvestigating bugs or performance problems.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "a"
          }
        }
      }
    },
    {
      "name": "trace",
      "comment": "Trace all past positions of a `Form` in the debugger. Add this to a `Form`\nand you will see a line tracing its entire history.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Form"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "watch",
      "comment": "Watch a particular value in the debugger. Say we want to know the value of\na variable called `velocity` because it may not be updated correctly. Adding\n`Debug.watch` allows us to name the value and show it with the debugger.\n\n\t  Debug.watch \"velocity\" velocity == velocity\n\nNotice that the result of evaluating this expression is exactly the same as\nnot having the expression at all. That means it's easy to add to any value.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "a"
          }
        }
      }
    },
    {
      "name": "watchSummary",
      "comment": "Watch a summary of a particular value in the debugger. This function is\npretty much the same as `watch` but it lets you specify a way to summarize\nthe value you are interested in. For example, maybe you only want to see part\nof a record:\n\n\t  Debug.watchSummary \"velocity\" .velocity object\n\nThis is the same as just writing `object`, but it creates a watch that *only*\nlooks at the value of `object.velocity`. You can also show summary statistics\nlike length of a list:\n\n\t  Debug.watchSummary \"Number of clicks\" length clicks\n\nAgain, this evaluates to `clicks` but we get to see how long that list is in\nthe debugger.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "a"
            }
          }
        }
      }
    }
  ]
}
,
{
  "name": "Dict",
  "comment": "A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time. Dictionary\nequality with `(==)` is unreliable and should not be used.\n\n# Build\n@docs empty, singleton, insert, update, remove\n\n# Query\n@docs member, get\n\n# Combine\n@docs union, intersect, diff\n\n# Lists\n@docs keys, values, toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "diff",
      "comment": "Keep a key-value pair when its key does not appear in the second dictionary.\nPreference is given to the first dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Dict"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            },
            {
              "tag": "var",
              "name": "v"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          }
        }
      }
    },
    {
      "name": "empty",
      "comment": "Create an empty dictionary.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Dict"
        },
        "args": [
          {
            "tag": "var",
            "name": "comparable"
          },
          {
            "tag": "var",
            "name": "v"
          }
        ]
      }
    },
    {
      "name": "filter",
      "comment": "Keep a key-value pair when it satisfies a predicate.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "v"
            },
            "out": {
              "tag": "type",
              "name": "Bool"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          }
        }
      }
    },
    {
      "name": "foldl",
      "comment": "Fold over the key-value pairs in a dictionary, in order from lowest\nkey to highest key.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "v"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "b"
              },
              "out": {
                "tag": "var",
                "name": "b"
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Dict"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "foldr",
      "comment": "Fold over the key-value pairs in a dictionary, in order from highest\nkey to lowest key.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "v"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "b"
              },
              "out": {
                "tag": "var",
                "name": "b"
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Dict"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "fromList",
      "comment": "Convert an association list into a dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Dict"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            },
            {
              "tag": "var",
              "name": "v"
            }
          ]
        }
      }
    },
    {
      "name": "get",
      "comment": "Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals = fromList [ (\"Tom\", Cat), (\"Jerry\", Mouse) ]\n\n    get \"Tom\"   animals == Just Cat\n    get \"Mouse\" animals == Just Mouse\n    get \"Spike\" animals == Nothing",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "v"
              }
            ]
          }
        }
      }
    },
    {
      "name": "insert",
      "comment": "Insert a key-value pair into a dictionary. Replaces value when there is\na collision.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "v"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Dict"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Dict"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "intersect",
      "comment": "Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Dict"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            },
            {
              "tag": "var",
              "name": "v"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          }
        }
      }
    },
    {
      "name": "keys",
      "comment": "Get all of the keys in a dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Dict"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            },
            {
              "tag": "var",
              "name": "v"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        }
      }
    },
    {
      "name": "map",
      "comment": "Apply a function to all values in a dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "member",
      "comment": "Determine if a key is in a dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "partition",
      "comment": "Partition a dictionary according to a predicate. The first dictionary\ncontains all key-value pairs which satisfy the predicate, and the second\ncontains the rest.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "v"
            },
            "out": {
              "tag": "type",
              "name": "Bool"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Dict"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "comparable"
                  },
                  {
                    "tag": "var",
                    "name": "v"
                  }
                ]
              },
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Dict"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "comparable"
                  },
                  {
                    "tag": "var",
                    "name": "v"
                  }
                ]
              }
            ]
          }
        }
      }
    },
    {
      "name": "remove",
      "comment": "Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          }
        }
      }
    },
    {
      "name": "singleton",
      "comment": "Create a dictionary with one key-value pair.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "v"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          }
        }
      }
    },
    {
      "name": "toList",
      "comment": "Convert a dictionary into an association list of key-value pairs.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Dict"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            },
            {
              "tag": "var",
              "name": "v"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "union",
      "comment": "Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Dict"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            },
            {
              "tag": "var",
              "name": "v"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Dict"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              },
              {
                "tag": "var",
                "name": "v"
              }
            ]
          }
        }
      }
    },
    {
      "name": "update",
      "comment": "Update the value of a dictionary for a specific key with a given function.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            }
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Dict"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Dict"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                },
                {
                  "tag": "var",
                  "name": "v"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "values",
      "comment": "Get all of the values in a dictionary.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Dict"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            },
            {
              "tag": "var",
              "name": "v"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "v"
            }
          ]
        }
      }
    }
  ]
}
,
{
  "name": "Graphics.Element",
  "comment": "Graphical elements that snap together to build complex widgets and layouts.\nEach Element is a rectangle with a known width and height, making them easy to\ncombine and position.\n\n# Images\n@docs image, fittedImage, croppedImage, tiledImage\n\n# Styling\n@docs width, height, size, color, opacity, link, tag\n\n# Inspection\n@docs widthOf, heightOf, sizeOf\n\n# Layout\n@docs flow, up, down, left, right, inward, outward\n\n## Layout Aliases\nThere are also some convenience functions for working\nwith `flow` in specific cases:\n\n@docs layers, above, below, beside\n\n# Positioning\n@docs empty, spacer, container\n\n## Specific Positions\n\nTo create a `Position` you can use any of the built-in positions\nwhich cover nine common positions.\n@docs middle, midTop, midBottom, midLeft, midRight, topLeft, topRight,\n      bottomLeft, bottomRight\n\nIf you need more precision, you can create custom positions.\n\n@docs absolute, relative, middleAt, midTopAt, midBottomAt, midLeftAt,\n      midRightAt, topLeftAt, topRightAt, bottomLeftAt, bottomRightAt",
  "aliases": [
    {
      "name": "Position",
      "comment": "",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "horizontal",
            {
              "tag": "type",
              "name": "Three"
            }
          ],
          [
            "vertical",
            {
              "tag": "type",
              "name": "Three"
            }
          ],
          [
            "x",
            {
              "tag": "type",
              "name": "Pos"
            }
          ],
          [
            "y",
            {
              "tag": "type",
              "name": "Pos"
            }
          ]
        ]
      }
    },
    {
      "name": "Element",
      "comment": "",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "props",
            {
              "tag": "type",
              "name": "Properties"
            }
          ],
          [
            "element",
            {
              "tag": "type",
              "name": "ElementPrim"
            }
          ]
        ]
      }
    },
    {
      "name": "Properties",
      "comment": "",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "id",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "width",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "height",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "opacity",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "color",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Color"
                }
              ]
            }
          ],
          [
            "href",
            {
              "tag": "type",
              "name": "String"
            }
          ],
          [
            "tag",
            {
              "tag": "type",
              "name": "String"
            }
          ],
          [
            "hover",
            {
              "tag": "type",
              "name": "_Tuple0"
            }
          ],
          [
            "click",
            {
              "tag": "type",
              "name": "_Tuple0"
            }
          ]
        ]
      }
    }
  ],
  "types": [
    {
      "name": "Direction",
      "comment": "",
      "args": [],
      "cases": [
        [
          "DUp",
          []
        ],
        [
          "DDown",
          []
        ],
        [
          "DLeft",
          []
        ],
        [
          "DRight",
          []
        ],
        [
          "DIn",
          []
        ],
        [
          "DOut",
          []
        ]
      ]
    },
    {
      "name": "Pos",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Absolute",
          [
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        ],
        [
          "Relative",
          [
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        ]
      ]
    },
    {
      "name": "Three",
      "comment": "",
      "args": [],
      "cases": [
        [
          "P",
          []
        ],
        [
          "Z",
          []
        ],
        [
          "N",
          []
        ]
      ]
    },
    {
      "name": "ImageStyle",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Plain",
          []
        ],
        [
          "Fitted",
          []
        ],
        [
          "Cropped",
          [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Int"
                },
                {
                  "tag": "type",
                  "name": "Int"
                }
              ]
            }
          ]
        ],
        [
          "Tiled",
          []
        ]
      ]
    },
    {
      "name": "ElementPrim",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Image",
          [
            {
              "tag": "type",
              "name": "ImageStyle"
            },
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "String"
            }
          ]
        ],
        [
          "Container",
          [
            {
              "tag": "type",
              "name": "Position"
            },
            {
              "tag": "type",
              "name": "Element"
            }
          ]
        ],
        [
          "Flow",
          [
            {
              "tag": "type",
              "name": "Direction"
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Element"
                }
              ]
            }
          ]
        ],
        [
          "Spacer",
          []
        ],
        [
          "RawHtml",
          []
        ],
        [
          "Custom",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "above",
      "comment": "Stack elements vertically.\nTo put `a` above `b` you would say: ``a `above` b``",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Element"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "absolute",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "type",
          "name": "Pos"
        }
      }
    },
    {
      "name": "below",
      "comment": "Stack elements vertically.\nTo put `a` below `b` you would say: ``a `below` b``",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Element"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "beside",
      "comment": "Put elements beside each other horizontally.\nTo put `a` beside `b` you would say: ``a `beside` b``",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Element"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "bottomLeft",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "bottomLeftAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "bottomRight",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "bottomRightAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "color",
      "comment": "Create an `Element` with a given background color.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "container",
      "comment": "Put an element in a container. This lets you position the element really\neasily, and there are tons of ways to set the `Position`.\nTo center `element` exactly in a 300-by-300 square you would say:\n\n    container 300 300 middle element\n\nBy setting the color of the container, you can create borders.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Position"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Element"
              },
              "out": {
                "tag": "type",
                "name": "Element"
              }
            }
          }
        }
      }
    },
    {
      "name": "croppedImage",
      "comment": "Create a cropped image. Take a rectangle out of the picture starting\nat the given top left coordinate. If you have a 140-by-140 image,\nthe following will cut a 100-by-100 square out of the middle of it.\n\n    croppedImage (20,20) 100 100 \"yogi.jpg\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Int"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "String"
              },
              "out": {
                "tag": "type",
                "name": "Element"
              }
            }
          }
        }
      }
    },
    {
      "name": "down",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Direction"
      }
    },
    {
      "name": "empty",
      "comment": "An Element that takes up no space. Good for things that appear conditionally:\n\n    flow down [ img1, if showMore then img2 else empty ]",
      "type": {
        "tag": "type",
        "name": "Element"
      }
    },
    {
      "name": "fittedImage",
      "comment": "Create a fitted image given a width, height, and image source.\nThis will crop the picture to best fill the given dimensions.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "Element"
            }
          }
        }
      }
    },
    {
      "name": "flow",
      "comment": "Have a list of elements flow in a particular direction.\nThe `Direction` starts from the first element in the list.\n\n    flow right [a,b,c]\n\n        +---+---+---+\n        | a | b | c |\n        +---+---+---+",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Direction"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "Element"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "height",
      "comment": "Create an `Element` with a given height.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "heightOf",
      "comment": "Get the height of an Element",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Element"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "image",
      "comment": "Create an image given a width, height, and image source.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "Element"
            }
          }
        }
      }
    },
    {
      "name": "inward",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Direction"
      }
    },
    {
      "name": "layers",
      "comment": "Layer elements on top of each other, starting from the bottom:\n`layers == flow outward`",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "Element"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "left",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Direction"
      }
    },
    {
      "name": "link",
      "comment": "Create an `Element` that is a hyper-link.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "midBottom",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "midBottomAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "midLeft",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "midLeftAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "midRight",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "midRightAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "midTop",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "midTopAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "middle",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "middleAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "opacity",
      "comment": "Create an `Element` with a given opacity. Opacity is a number between 0 and 1\nwhere 0 means totally clear.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "outward",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Direction"
      }
    },
    {
      "name": "relative",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Pos"
        }
      }
    },
    {
      "name": "right",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Direction"
      }
    },
    {
      "name": "size",
      "comment": "Create an `Element` with a new width and height.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Element"
            },
            "out": {
              "tag": "type",
              "name": "Element"
            }
          }
        }
      }
    },
    {
      "name": "sizeOf",
      "comment": "Get the width and height of an Element",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Element"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        }
      }
    },
    {
      "name": "spacer",
      "comment": "Create an empty box. This is useful for getting your spacing right and\nfor making borders.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "tag",
      "comment": "Create an `Element` with a tag. This lets you link directly to it.\nThe element `(tag \"all-about-badgers\" thirdParagraph)` can be reached\nwith a link like this: `/facts-about-animals.elm#all-about-badgers`",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "tiledImage",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "Element"
            }
          }
        }
      }
    },
    {
      "name": "topLeft",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "topLeftAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "topRight",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Position"
      }
    },
    {
      "name": "topRightAt",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Pos"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Pos"
          },
          "out": {
            "tag": "type",
            "name": "Position"
          }
        }
      }
    },
    {
      "name": "up",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Direction"
      }
    },
    {
      "name": "width",
      "comment": "Create an `Element` with a given width.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "widthOf",
      "comment": "Get the width of an Element",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Element"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    }
  ]
}
,
{
  "name": "Graphics.Collage",
  "comment": "The collage API is for freeform graphics. You can move, rotate, scale, etc.\nall sorts of forms including lines, shapes, images, and elements.\n\nCollages use the same coordinate system you might see in an algebra or physics\nproblem. The origin (0,0) is at the center of the collage, not the top left\ncorner as in some other graphics libraries. Furthermore, the y-axis points up,\nso moving a form 10 units in the y-axis will move it up on screen.\n\n# Unstructured Graphics\n@docs collage\n \n# Creating Forms\n@docs toForm, filled, textured, gradient, outlined, traced\n \n# Transforming Forms\n@docs move, moveX, moveY, scale, rotate, alpha\n \n# Grouping Forms\nGrouping forms makes it easier to write modular graphics code. You can create\na form that is a composite of many subforms. From there it is easy to transform\nit as a single unit.\n\n@docs group, groupTransform\n \n# Shapes\n@docs rect, oval, square, circle, ngon, polygon\n\n# Paths\n@docs segment, path\n \n# Line Styles\n@docs solid, dashed, dotted, LineStyle, LineCap, LineJoin, defaultLine",
  "aliases": [
    {
      "name": "Shape",
      "comment": "",
      "args": [],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "List"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "type",
                "name": "Float"
              },
              {
                "tag": "type",
                "name": "Float"
              }
            ]
          }
        ]
      }
    },
    {
      "name": "Path",
      "comment": "",
      "args": [],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "List"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "type",
                "name": "Float"
              },
              {
                "tag": "type",
                "name": "Float"
              }
            ]
          }
        ]
      }
    },
    {
      "name": "LineStyle",
      "comment": "All of the attributes of a line style. This lets you build up a line style\nhowever you want. You can also update existing line styles with record updates.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "color",
            {
              "tag": "type",
              "name": "Color"
            }
          ],
          [
            "width",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "cap",
            {
              "tag": "type",
              "name": "LineCap"
            }
          ],
          [
            "join",
            {
              "tag": "type",
              "name": "LineJoin"
            }
          ],
          [
            "dashing",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Int"
                }
              ]
            }
          ],
          [
            "dashOffset",
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        ]
      }
    },
    {
      "name": "Form",
      "comment": "",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "theta",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "scale",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "x",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "y",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "alpha",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "form",
            {
              "tag": "type",
              "name": "BasicForm"
            }
          ]
        ]
      }
    }
  ],
  "types": [
    {
      "name": "ShapeStyle",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Line",
          [
            {
              "tag": "type",
              "name": "LineStyle"
            }
          ]
        ],
        [
          "Fill",
          [
            {
              "tag": "type",
              "name": "FillStyle"
            }
          ]
        ]
      ]
    },
    {
      "name": "BasicForm",
      "comment": "",
      "args": [],
      "cases": [
        [
          "FPath",
          [
            {
              "tag": "type",
              "name": "LineStyle"
            },
            {
              "tag": "type",
              "name": "Path"
            }
          ]
        ],
        [
          "FShape",
          [
            {
              "tag": "type",
              "name": "ShapeStyle"
            },
            {
              "tag": "type",
              "name": "Shape"
            }
          ]
        ],
        [
          "FImage",
          [
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Int"
                },
                {
                  "tag": "type",
                  "name": "Int"
                }
              ]
            },
            {
              "tag": "type",
              "name": "String"
            }
          ]
        ],
        [
          "FElement",
          [
            {
              "tag": "type",
              "name": "Element"
            }
          ]
        ],
        [
          "FGroup",
          [
            {
              "tag": "type",
              "name": "Transform2D"
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Form"
                }
              ]
            }
          ]
        ]
      ]
    },
    {
      "name": "LineJoin",
      "comment": "The shape of the &ldquo;joints&rdquo; of a line, where each line segment\nmeets. `Sharp` takes an argument to limit the length of the joint. This\ndefaults to 10.",
      "args": [],
      "cases": [
        [
          "Smooth",
          []
        ],
        [
          "Sharp",
          [
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        ],
        [
          "Clipped",
          []
        ]
      ]
    },
    {
      "name": "LineCap",
      "comment": "The shape of the ends of a line.",
      "args": [],
      "cases": [
        [
          "Flat",
          []
        ],
        [
          "Round",
          []
        ],
        [
          "Padded",
          []
        ]
      ]
    },
    {
      "name": "FillStyle",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Solid",
          [
            {
              "tag": "type",
              "name": "Color"
            }
          ]
        ],
        [
          "Texture",
          [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        ],
        [
          "Grad",
          [
            {
              "tag": "type",
              "name": "Gradient"
            }
          ]
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "alpha",
      "comment": "Set the alpha of a `Form`. The default is 1, and 0 is totally transparent.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Form"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "circle",
      "comment": "A circle with a given radius.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Shape"
        }
      }
    },
    {
      "name": "collage",
      "comment": "A collage is a collection of 2D forms. There are no strict positioning\nrelationships between forms, so you are free to do all kinds of 2D graphics.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Form"
                }
              ]
            },
            "out": {
              "tag": "type",
              "name": "Element"
            }
          }
        }
      }
    },
    {
      "name": "dashed",
      "comment": "Create a dashed line style with a given color. Dashing equals `[8,4]`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "type",
          "name": "LineStyle"
        }
      }
    },
    {
      "name": "defaultLine",
      "comment": "The default line style, which is solid black with flat caps and sharp joints.\nYou can use record updates to build the line style you\nwant. For example, to make a thicker line, you could say:\n\n    { defaultLine | width \u003c- 10 }",
      "type": {
        "tag": "type",
        "name": "LineStyle"
      }
    },
    {
      "name": "dotted",
      "comment": "Create a dotted line style with a given color. Dashing equals `[3,3]`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "type",
          "name": "LineStyle"
        }
      }
    },
    {
      "name": "filled",
      "comment": "Create a filled in shape.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Shape"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "form",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "BasicForm"
        },
        "out": {
          "tag": "type",
          "name": "Form"
        }
      }
    },
    {
      "name": "gradient",
      "comment": "Fill a shape with a [gradient](Color#linear).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Gradient"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Shape"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "group",
      "comment": "Flatten many forms into a single `Form`. This lets you move and rotate them\nas a single unit, making it possible to build small, modular components.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "Form"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Form"
        }
      }
    },
    {
      "name": "groupTransform",
      "comment": "Flatten many forms into a single `Form` and then apply a matrix\ntransformation.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Transform2D"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "Form"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "move",
      "comment": "Move a form by the given amount. This is a relative translation so\n`(move (10,10) form)` would move `form` ten pixels up and ten pixels to the\nright.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Form"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "moveX",
      "comment": "Move a shape in the x direction. This is relative so `(moveX 10 form)` moves\n`form` 10 pixels to the right.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Form"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "moveY",
      "comment": "Move a shape in the y direction. This is relative so `(moveY 10 form)` moves\n`form` upwards by 10 pixels.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Form"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "ngon",
      "comment": "A regular polygon with N sides. The first argument specifies the number\nof sides and the second is the radius. So to create a pentagon with radius\n30 you would say:\n\n    ngon 5 30",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Shape"
          }
        }
      }
    },
    {
      "name": "outlined",
      "comment": "Outline a shape with a given line style.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "LineStyle"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Shape"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "oval",
      "comment": "An oval with a given width and height.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Shape"
          }
        }
      }
    },
    {
      "name": "path",
      "comment": "Create a path that follows a sequence of points.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Path"
        }
      }
    },
    {
      "name": "polygon",
      "comment": "Create an arbitrary polygon by specifying its corners in order.\n`polygon` will automatically close all shapes, so the given list\nof points does not need to start and end with the same position.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                },
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Shape"
        }
      }
    },
    {
      "name": "rect",
      "comment": "A rectangle with a given width and height.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Shape"
          }
        }
      }
    },
    {
      "name": "rotate",
      "comment": "Rotate a form by a given angle. Rotate takes standard Elm angles (radians)\nand turns things counterclockwise. So to turn `form` 30&deg; to the left\nyou would say, `(rotate (degrees 30) form)`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Form"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "scale",
      "comment": "Scale a form by a given factor. Scaling by 2 doubles both dimensions,\nand quadruples the area.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Form"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "segment",
      "comment": "Create a path along a given line segment.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "type",
              "name": "Float"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "type",
                "name": "Float"
              },
              {
                "tag": "type",
                "name": "Float"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Path"
          }
        }
      }
    },
    {
      "name": "solid",
      "comment": "Create a solid line style with a given color.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "type",
          "name": "LineStyle"
        }
      }
    },
    {
      "name": "sprite",
      "comment": "Create a sprite from a sprite sheet. It cuts out a rectangle\nat a given position.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Int"
                },
                {
                  "tag": "type",
                  "name": "Int"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "String"
              },
              "out": {
                "tag": "type",
                "name": "Form"
              }
            }
          }
        }
      }
    },
    {
      "name": "square",
      "comment": "A square with a given edge length.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Shape"
        }
      }
    },
    {
      "name": "textured",
      "comment": "Create a textured shape. The texture is described by some url and is\ntiled to fill the entire shape.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Shape"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    },
    {
      "name": "toForm",
      "comment": "Turn any `Element` into a `Form`. This lets you use text, gifs, and video\nin your collage. This means you can move, rotate, and scale\nan `Element` however you want.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Element"
        },
        "out": {
          "tag": "type",
          "name": "Form"
        }
      }
    },
    {
      "name": "traced",
      "comment": "Trace a path with a given line style.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "LineStyle"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Path"
          },
          "out": {
            "tag": "type",
            "name": "Form"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Graphics.Input",
  "comment": "This module is for creating input widgets such as buttons and text fields.\nAll functions in this library report to a [`Signal.Channel`](Signal#send).\n\n# Basic Input Elements\n\nTo learn about text fields, see the\n[`Graphics.Input.Field`](Graphics-Input-Field) library.\n\n@docs button, customButton, checkbox, dropDown\n\n# Clicks and Hovers\n@docs clickable, hoverable",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "button",
      "comment": "Create a standard button. The following example begins making a basic\ncalculator:\n\n    type Keys = Number Int | Plus | Minus | Clear\n\n    keys : Signal.Channel Keys\n    keys = Signal.channel Clear\n\n    calculator : Element\n    calculator =\n        flow right\n          [ button (Signal.send keys (Number 1)) \"1\"\n          , button (Signal.send keys (Number 2)) \"2\"\n          , button (Signal.send keys    Plus   ) \"+\"\n          ]\n\nIf the user presses the \"+\" button, `keys.signal` will update to `Plus`. If the\nusers presses \"2\", `keys.signal` will update to `(Number 2)`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Signal.Message"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "checkbox",
      "comment": "Create a checkbox. The following example creates three synced checkboxes:\n\n    check : Signal.Channel Bool\n    check = Signal.channel False\n\n    boxes : Bool -\u003e Element\n    boxes checked =\n        let box = container 40 40 middle (checkbox (Signal.send check) checked)\n        in\n            flow right [ box, box, box ]\n\n    main : Signal Element\n    main = boxes \u003c~ Signal.subscribe check",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Bool"
          },
          "out": {
            "tag": "type",
            "name": "Signal.Message"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Bool"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "clickable",
      "comment": "Detect mouse clicks on a specific `Element`. In the following example,\nwe will create a clickable picture called `cat`.\n\n    type Picture = Cat | Hat\n\n    picture : Signal.Channel Picture\n    picture = Signal.channel Cat\n\n    cat : Element\n    cat =\n      image 30 30 \"/cat.jpg\"\n        |\u003e clickable (Signal.send picture Cat)\n\n    hat : Element\n    hat =\n      image 30 30 \"/hat.jpg\"\n        |\u003e clickable (Signal.send picture Hat)\n\nWhen the user clicks on the `cat` element, `picture.signal` receives\nan update containing the value `Cat`. When the user clicks on the `hat` element,\n`picture.signal` receives an update containing the value `Hat`. This lets you\ndistinguish which element was clicked. In a more complex example, they could be\ndistinguished with IDs or more complex data structures.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Signal.Message"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "customButton",
      "comment": "Same as `button` but lets you customize buttons to look however you want.\n\n    click : Signal.Channel ()\n    click = Signal.channel ()\n\n    prettyButton : Element\n    prettyButton =\n        customButton (Signal.send click ())\n            (image 100 40 \"/button_up.jpg\")\n            (image 100 40 \"/button_hover.jpg\")\n            (image 100 40 \"/button_down.jpg\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Signal.Message"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Element"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Element"
              },
              "out": {
                "tag": "type",
                "name": "Element"
              }
            }
          }
        }
      }
    },
    {
      "name": "dropDown",
      "comment": "Create a drop-down menu.  The following drop-down lets you choose your\nfavorite British sport:\n\n    type Sport = Football | Cricket | Snooker\n\n    sport : Signal.Channel (Maybe Sport)\n    sport = Signal.channel Nothing\n\n    sportDropDown : Element\n    sportDropDown =\n        dropDown (Signal.send sport)\n          [ (\"\"        , Nothing)\n          , (\"Football\", Just Football)\n          , (\"Cricket\" , Just Cricket)\n          , (\"Snooker\" , Just Snooker)\n          ]\n\nIf the user selects \"Football\" from the drop down menue, `Signal.subscribe sport`\nwill update to `Just Football`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Signal.Message"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "_Tuple2"
                },
                "args": [
                  {
                    "tag": "type",
                    "name": "String"
                  },
                  {
                    "tag": "var",
                    "name": "a"
                  }
                ]
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    },
    {
      "name": "hoverable",
      "comment": "Detect mouse hovers over a specific `Element`. In the following example,\nwe will create a hoverable picture called `cat`.\n\n    hover : Signal.Channel Bool\n    hover = Signal.channel False\n\n    cat : Element\n    cat =\n      image 30 30 \"/cat.jpg\"\n        |\u003e hoverable (Signal.send hover)\n\nWhen the mouse hovers above the `cat` element, `hover.signal` will become\n`True`. When the mouse leaves it, `hover.signal` will become `False`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Bool"
          },
          "out": {
            "tag": "type",
            "name": "Signal.Message"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Element"
          },
          "out": {
            "tag": "type",
            "name": "Element"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Graphics.Input.Field",
  "comment": "This library provides an API for creating and updating text fields.\nText fields use exactly the same approach as [`Graphics.Input`](Graphics-Input)\nfor modelling user input, allowing you to keep track of new events and update\ntext fields programmatically.\n\n# Create Fields\n@docs field, password, email\n\n# Field Content\n@docs Content, Selection, Direction, noContent\n\n# Field Style\n@docs defaultStyle, Style, Outline, noOutline, Highlight, noHighlight, Dimensions, uniformly",
  "aliases": [
    {
      "name": "Selection",
      "comment": "The selection within a text field. `start` is never greater than `end`:\n\n    Selection 0 0 Forward  -- cursor precedes all characters\n\n    Selection 5 9 Backward -- highlighting characters starting after\n                           -- the 5th and ending after the 9th",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "start",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "end",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "direction",
            {
              "tag": "type",
              "name": "Direction"
            }
          ]
        ]
      }
    },
    {
      "name": "Content",
      "comment": "Represents the current content of a text field. For example:\n\n    content = Content \"She sells sea shells\" (Selection 0 3 Backward)\n\nThis means the user highlighted the substring `\"She\"` backwards. The value of\n`content.string` is `\"She sells sea shells\"`.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "string",
            {
              "tag": "type",
              "name": "String"
            }
          ],
          [
            "selection",
            {
              "tag": "type",
              "name": "Selection"
            }
          ]
        ]
      }
    },
    {
      "name": "Style",
      "comment": "Describe the style of a text box. `style` describes the style of the text\nitself using [`Text.Style`](/Text#Style). `highlight` describes the glowing blue\nhighlight that shows up when the field has focus. `outline` describes the line\nsurrounding the text field, and `padding` adds whitespace between the `outline`\nand the text.\n\nThe width and height of the text box *includes* the `padding` and `outline`.\nSay we have a text box that is 40 pixels tall. It has a uniform outline of\n1 pixel and a uniform padding of 5 pixels. Both of these must be subtracted\nfrom the total height to determine how much room there is for text. The\n`padding` and `outline` appear on the top and bottom, so there will be 28\nvertical pixels remaining for the text (40 - 1 - 5 - 5 - 1).",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "padding",
            {
              "tag": "type",
              "name": "Dimensions"
            }
          ],
          [
            "outline",
            {
              "tag": "type",
              "name": "Outline"
            }
          ],
          [
            "highlight",
            {
              "tag": "type",
              "name": "Highlight"
            }
          ],
          [
            "style",
            {
              "tag": "type",
              "name": "Text.Style"
            }
          ]
        ]
      }
    },
    {
      "name": "Highlight",
      "comment": "When a field has focus, it has a blue highlight around it by default. The\n`Highlight` lets you set the `color` and `width` of this highlight. Set the\n`width` to zero to turn the highlight off. Here is an example highlight that\nis blue and thin:\n\n    { color = blue, width = 1 }",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "color",
            {
              "tag": "type",
              "name": "Color"
            }
          ],
          [
            "width",
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        ]
      }
    },
    {
      "name": "Outline",
      "comment": "A field can have a outline around it. This lets you set its color, width,\nand radius. The radius allows you to round the corners of your field. Set the\nwidth to zero to make it invisible. Here is an example outline that is grey\nand thin with slightly rounded corners:\n\n    { color = grey, width = uniformly 1, radius = 4 }",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "color",
            {
              "tag": "type",
              "name": "Color"
            }
          ],
          [
            "width",
            {
              "tag": "type",
              "name": "Dimensions"
            }
          ],
          [
            "radius",
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        ]
      }
    },
    {
      "name": "Dimensions",
      "comment": "For setting dimensions of a field's padding or outline. The left, right,\ntop, and bottom may all have different sizes. The following example creates\ndimensions such that the left and right are twice as wide as the top and bottom:\n\n    myDimensions : Int -\u003e Dimensions\n    myDimensions n =\n        { left = 2 * n\n        , right = 2 * n\n        , top = n\n        , bottom = n\n        }",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "left",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "right",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "top",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "bottom",
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        ]
      }
    }
  ],
  "types": [
    {
      "name": "Direction",
      "comment": "The direction of selection. When the user highlights a selection in a text\nfield, they must do it in a particular direction. This determines which end of\nthe selection moves when they change the selection by pressing Shift-Left or\nShift-Right.",
      "args": [],
      "cases": [
        [
          "Forward",
          []
        ],
        [
          "Backward",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "defaultStyle",
      "comment": "The default style for a text field. The outline is `Color.grey` with width\n1 and radius 2. The highlight is `Color.blue` with width 1, and the default\ntext color is black.",
      "type": {
        "tag": "type",
        "name": "Style"
      }
    },
    {
      "name": "email",
      "comment": "Same as `field` but it adds an annotation that this field is for email\naddresses. This is helpful for auto-complete and for mobile users who may\nget a custom keyboard with an `@` and `.com` button.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Style"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Content"
            },
            "out": {
              "tag": "type",
              "name": "Signal.Message"
            }
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Content"
              },
              "out": {
                "tag": "type",
                "name": "Element"
              }
            }
          }
        }
      }
    },
    {
      "name": "field",
      "comment": "Create a text field. The following example creates a time-varying element\ncalled `nameField`. As the user types their name, the field will be updated\nto match what they have entered.\n\n    name : Signal.Channel Content\n    name = Signal.channel noContent\n\n    nameField : Signal Element\n    nameField =\n        field defaultStyle (Signal.send name) \"Name\" \u003c~ Signal.subscribe name\n\nWhen we use the `field` function, we first give it a visual style. This is\nthe first argument so that it is easier to define your own custom field\n(`myField = field myStyle`). The next two arguments are a `Handle` and a\nhandler function that processes or augments events before sending them along\nto the associated `Input`. In the example above we use the `identity` function to\npass events along unchanged to the `name` `Input`. We then provide the\nplace-holder message to use when no input has been provided yet. Finally,\nwe give the current `Content` of the field. This argument is last because\nit is most likely to change frequently, making function composition easier.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Style"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Content"
            },
            "out": {
              "tag": "type",
              "name": "Signal.Message"
            }
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Content"
              },
              "out": {
                "tag": "type",
                "name": "Element"
              }
            }
          }
        }
      }
    },
    {
      "name": "noContent",
      "comment": "A field with no content:\n\n    Content \"\" (Selection 0 0 Forward)",
      "type": {
        "tag": "type",
        "name": "Content"
      }
    },
    {
      "name": "noHighlight",
      "comment": "A highlight with zero width, so you cannot see it.",
      "type": {
        "tag": "type",
        "name": "Highlight"
      }
    },
    {
      "name": "noOutline",
      "comment": "An outline with zero width, so you cannot see it.",
      "type": {
        "tag": "type",
        "name": "Outline"
      }
    },
    {
      "name": "password",
      "comment": "Same as `field` but the UI element blocks out each characters.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Style"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Content"
            },
            "out": {
              "tag": "type",
              "name": "Signal.Message"
            }
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Content"
              },
              "out": {
                "tag": "type",
                "name": "Element"
              }
            }
          }
        }
      }
    },
    {
      "name": "uniformly",
      "comment": "Create uniform dimensions:\n\n    uniformly 4 == { left=4, right=4, top=4, bottom=4 }\n\nThe following example creates an outline where the left, right, top, and bottom\nedges all have width 1:\n\n    Outline grey (uniformly 1) 4",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "type",
          "name": "Dimensions"
        }
      }
    }
  ]
}
,
{
  "name": "Http",
  "comment": "A library for asynchronous HTTP requests. See the `WebSocket`\nlibrary if you have very strict latency requirements.\n\n# Sending Requests\n@docs send, sendGet\n\n# Creating Requests\n@docs get, post, request\n\n# Responses\n@docs Response",
  "aliases": [
    {
      "name": "Request",
      "comment": "",
      "args": [
        "a"
      ],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "verb",
            {
              "tag": "type",
              "name": "String"
            }
          ],
          [
            "url",
            {
              "tag": "type",
              "name": "String"
            }
          ],
          [
            "body",
            {
              "tag": "var",
              "name": "a"
            }
          ],
          [
            "headers",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "_Tuple2"
                  },
                  "args": [
                    {
                      "tag": "type",
                      "name": "String"
                    },
                    {
                      "tag": "type",
                      "name": "String"
                    }
                  ]
                }
              ]
            }
          ]
        ]
      }
    }
  ],
  "types": [
    {
      "name": "Response",
      "comment": "The datatype for responses. Success contains only the returned message.\nFailures contain both an error code and an error message.",
      "args": [
        "a"
      ],
      "cases": [
        [
          "Success",
          [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        ],
        [
          "Waiting",
          []
        ],
        [
          "Failure",
          [
            {
              "tag": "type",
              "name": "Int"
            },
            {
              "tag": "type",
              "name": "String"
            }
          ]
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "get",
      "comment": "Create a GET request to the given url.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Request"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        }
      }
    },
    {
      "name": "post",
      "comment": "Create a POST request to the given url, carrying the given data.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Request"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              }
            ]
          }
        }
      }
    },
    {
      "name": "request",
      "comment": "Create a customized request. Arguments are request type (get, post, put,\ndelete, etc.), target url, data, and a list of additional headers.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "_Tuple2"
                    },
                    "args": [
                      {
                        "tag": "type",
                        "name": "String"
                      },
                      {
                        "tag": "type",
                        "name": "String"
                      }
                    ]
                  }
                ]
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Request"
                },
                "args": [
                  {
                    "tag": "type",
                    "name": "String"
                  }
                ]
              }
            }
          }
        }
      }
    },
    {
      "name": "send",
      "comment": "Performs an HTTP request with the given requests. Produces a signal\nthat carries the responses.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Request"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Response"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "sendGet",
      "comment": "Performs an HTTP GET request with the given urls. Produces a signal\nthat carries the responses.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Response"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            }
          ]
        }
      }
    }
  ]
}
,
{
  "name": "Json.Decode",
  "comment": "A way to turn JSON strings and JS values into Elm values.\n\n# Run a Decoder\n@docs decodeString, decodeValue\n\n# Primitives\n@docs string, int, float, bool, null\n\n# Arrays\n@docs list, array,\n  tuple1, tuple2, tuple3, tuple4, tuple5, tuple6, tuple7, tuple8\n\n# Objects\n@docs (:=), at,\n  object1, object2, object3, object4, object5, object6, object7, object8,\n  keyValuePairs, dict\n\n# Oddly Shaped Values\n@docs maybe, oneOf, map, fail, succeed, andThen\n\n# \"Creative\" Values\n@docs value, customDecoder",
  "aliases": [
    {
      "name": "Value",
      "comment": "",
      "args": [],
      "type": {
        "tag": "type",
        "name": "JsonEncode.Value"
      }
    }
  ],
  "types": [
    {
      "name": "Decoder",
      "comment": "",
      "args": [
        "a"
      ],
      "cases": [
        [
          "Decoder",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": ":=",
      "comment": "Decode an object if it has a certain field.\n\n    nameAndAge : Decoder (String,Int)\n    nameAndAge =\n        object2 (,)\n          (\"name\" := string)\n          (\"age\" := int)\n\n    optionalProfession : Decoder (Maybe String)\n    optionalProfession =\n        maybe (\"profession\" := string)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "andThen",
      "comment": "Helpful when one field will determine the shape of a bunch of other fields.\n\n    type Shape\n        = Rectangle Float Float\n        | Circle Float\n\n    shape : Decoder Shape\n    shape =\n      (\"tag\" := string) `andThen` shapeInfo\n\n    shapeInfo : String -\u003e Decoder Shape\n    shapeInfo tag =\n      case tag of\n        \"rectangle\" -\u003e\n            object2 Rectangle\n              (\"width\" := float)\n              (\"height\" := float)\n\n        \"circle\" -\u003e\n            object1 Circle\n              (\"radius\" := float)\n\n        _ -\u003e\n            fail (tag ++ \" is not a recognized tag for shapes\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "array",
      "comment": "Extract an Array from a JS array.\n\n    -- [1,2,3,4]\n\n    numbers : Decoder (Array Int)\n    numbers =\n        array int",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Array"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "at",
      "comment": "Access a nested field, making it easy to dive into big structures. This is\nreally a helper function so you do not need to write `(:=)` so many times.\n\n    -- object.target.value = 'hello'\n\n    value : Decoder String\n    value =\n        at [\"target\", \"value\"] string\n\n    at fields decoder =\n        List.foldr (:=) decoder fields",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "bool",
      "comment": "Extract a boolean.\n\n    -- { ... checked: true ... }\n\n    checked : Decoder Bool\n    checked =\n        \"checked\" := true",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Decoder"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "customDecoder",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Result"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                },
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "decodeString",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "decodeValue",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Value"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "dict",
      "comment": "Turn any object into a dictionary of key-value pairs.\n\n    -- { mercury: 0.33, venus: 4.87, earth: 5.97, ... }\n    planetMasses : Decoder (Dict String Int)\n    planetMasses =\n        dict float",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Dict"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                },
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "fail",
      "comment": "A decoder that always fails. Useful when paired with `andThen` or `oneOf`\nto improve error messages when things go wrong. For example, the following\ndecoder is able to provide a much more specific error message when `fail` is\nthe last option.\n\n    point : (Float,Float)\n    point =\n        oneOf\n        [ tuple2 (,) float float\n        , object2 (,) (\"x\" := float) (\"y\" := float)\n        , fail \"expecting some kind of point\"\n        ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "float",
      "comment": "Extract a float.\n\n    -- [ 6.022, 3.1415, 1.618 ]\n\n    numbers : Decoder (List Float)\n    numbers =\n        list float",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Decoder"
        },
        "args": [
          {
            "tag": "type",
            "name": "Float"
          }
        ]
      }
    },
    {
      "name": "int",
      "comment": "Extract an integer.\n\n    -- { ... age: 42 ... }\n\n    age : Decoder Int\n    age =\n        \"age\" := int",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Decoder"
        },
        "args": [
          {
            "tag": "type",
            "name": "Int"
          }
        ]
      }
    },
    {
      "name": "keyValuePairs",
      "comment": "Turn any object into a list of key-value pairs.\n\n    -- { tom: 89, sue: 92, bill: 97, ... }\n    grades : Decoder (List (String, Int))\n    grades =\n        keyValuePairs int",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "_Tuple2"
                  },
                  "args": [
                    {
                      "tag": "type",
                      "name": "String"
                    },
                    {
                      "tag": "var",
                      "name": "a"
                    }
                  ]
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "list",
      "comment": "Extract a list from a JS array.\n\n    -- [1,2,3,4]\n\n    numbers : Decoder [Int]\n    numbers =\n        list int",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "map",
      "comment": "Transform the value returned by a decoder. Most useful when paired with\nthe `oneOf` function.\n\n    nullOr : Decoder a -\u003e Decoder (Maybe a)\n    nullOr decoder =\n        oneOf\n          [ null Nothing\n          , map Just decoder\n          ]\n\n    type UserID = OldID Int | NewID String\n\n    -- 1234 or \"1234abc\"\n    userID : Decoder UserID\n    userID =\n        oneOf\n          [ map OldID int\n          , map NewID string\n          ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "maybe",
      "comment": "Great for handling optional fields. The following code decodes JSON\nobjects that may not have a profession field.\n\n    -- { name: \"Tom\", age: 31, profession: \"plumber\" }\n    -- { name: \"Sue\", age: 42 }\n\n    type alias Person =\n        { name : String\n        , age : Int\n        , profession : Maybe String\n        }\n\n    person : Decoder Person\n    person =\n        object3 Person\n          (\"name\" := string)\n          (\"age\" := int)\n          (maybe (\"profession\" := string))",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "null",
      "comment": "Extract a null value. Primarily useful for creating *other* decoders.\n\n    nullOr : Decoder a -\u003e Decoder (Maybe a)\n    nullOr decoder =\n        oneOf\n        [ null Nothing\n        , map Just decoder\n        ]\n\n\n    numbers : Decoder [Int]\n    numbers =\n        list (oneOf [ int, null 0 ])",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "object1",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "value"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "value"
              }
            ]
          }
        }
      }
    },
    {
      "name": "object2",
      "comment": "Use two different decoders on a JS value. This is nice for extracting\nmultiple fields from an object.\n\n    point : Decoder (Float,Float)\n    point =\n        object2 (,)\n          (\"x\" := float)\n          (\"y\" := float)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "value"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "value"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "object3",
      "comment": "Use two different decoders on a JS value. This is nice for extracting\nmultiple fields from an object.\n\n    type alias Task = { task : String, id : Int, completed : Bool }\n\n    point : Decoder (Float,Float)\n    point =\n        object3 Task\n          (\"task\" := string)\n          (\"id\" := int)\n          (\"completed\" := bool)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "var",
                "name": "value"
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "value"
                  }
                ]
              }
            }
          }
        }
      }
    },
    {
      "name": "object4",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "var",
                  "name": "value"
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "value"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "object5",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "var",
                    "name": "value"
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "value"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "object6",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "var",
                      "name": "f"
                    },
                    "out": {
                      "tag": "var",
                      "name": "value"
                    }
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "f"
                        }
                      ]
                    },
                    "out": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "value"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "object7",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "var",
                      "name": "f"
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "var",
                        "name": "g"
                      },
                      "out": {
                        "tag": "var",
                        "name": "value"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "f"
                        }
                      ]
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "app",
                        "func": {
                          "tag": "type",
                          "name": "Decoder"
                        },
                        "args": [
                          {
                            "tag": "var",
                            "name": "g"
                          }
                        ]
                      },
                      "out": {
                        "tag": "app",
                        "func": {
                          "tag": "type",
                          "name": "Decoder"
                        },
                        "args": [
                          {
                            "tag": "var",
                            "name": "value"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "object8",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "var",
                      "name": "f"
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "var",
                        "name": "g"
                      },
                      "out": {
                        "tag": "lambda",
                        "in": {
                          "tag": "var",
                          "name": "h"
                        },
                        "out": {
                          "tag": "var",
                          "name": "value"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "f"
                        }
                      ]
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "app",
                        "func": {
                          "tag": "type",
                          "name": "Decoder"
                        },
                        "args": [
                          {
                            "tag": "var",
                            "name": "g"
                          }
                        ]
                      },
                      "out": {
                        "tag": "lambda",
                        "in": {
                          "tag": "app",
                          "func": {
                            "tag": "type",
                            "name": "Decoder"
                          },
                          "args": [
                            {
                              "tag": "var",
                              "name": "h"
                            }
                          ]
                        },
                        "out": {
                          "tag": "app",
                          "func": {
                            "tag": "type",
                            "name": "Decoder"
                          },
                          "args": [
                            {
                              "tag": "var",
                              "name": "value"
                            }
                          ]
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "oneOf",
      "comment": "Try out a couple different decoders. This is helpful when you are dealing\nwith something with a very strange shape and when `andThen` does not help\nnarrow things down so you can be more targeted.\n\n    -- [ [3,4], { x:0, y:0 }, [5,12] ]\n\n    points : Decoder (List (Float,Float))\n    points =\n        list point\n\n    point : (Float,Float)\n    point =\n        oneOf\n        [ tuple2 (,) float float\n        , object2 (,) (\"x\" := float) (\"y\" := float)\n        ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "string",
      "comment": "Extract a string.\n\n    -- [\"John\",\"Doe\"]\n\n    name : Decoder (String, String)\n    name =\n        tuple2 (,) string string",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Decoder"
        },
        "args": [
          {
            "tag": "type",
            "name": "String"
          }
        ]
      }
    },
    {
      "name": "succeed",
      "comment": "A decoder that always succeeds. Useful when paired with `andThen` or\n`oneOf` but everything is supposed to work out at the end. For example,\nmaybe you have an optional field that can have a default value when it is\nmissing.\n\n    -- { x:3, y:4 } or { x:3, y:4, z:5 }\n\n    point3D : Decoder (Float,Float,Float)\n    point3D =\n        object (,,)\n          (\"x\" := float)\n          (\"y\" := float)\n          (oneOf [ \"z\" := float, succeed 0 ])",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Decoder"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "tuple1",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "value"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "value"
              }
            ]
          }
        }
      }
    },
    {
      "name": "tuple2",
      "comment": "Handle an array with exactly two values. Useful for points and simple\npairs.\n\n    -- [3,4] or [0,0]\n    point : Decoder (Float,Float)\n    point =\n        tuple2 (,) float float\n\n    -- [\"John\",\"Doe\"] or [\"Hermann\",\"Hesse\"]\n    name : Decoder Name\n    name =\n        tuple2 Name string string\n\n    type alias Name = { first : String, last : String }",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "value"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "value"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "tuple3",
      "comment": "Handle an array with exactly three values.\n\n    -- [3,4,5] or [0,0,0]\n    point3D : Decoder (Float,Float,Float)\n    point3D =\n        tuple3 (,,) float float float",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "var",
                "name": "value"
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "value"
                  }
                ]
              }
            }
          }
        }
      }
    },
    {
      "name": "tuple4",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "var",
                  "name": "value"
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "value"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "tuple5",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "var",
                    "name": "value"
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "value"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "tuple6",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "var",
                      "name": "f"
                    },
                    "out": {
                      "tag": "var",
                      "name": "value"
                    }
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "f"
                        }
                      ]
                    },
                    "out": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "value"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "tuple7",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "var",
                      "name": "f"
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "var",
                        "name": "g"
                      },
                      "out": {
                        "tag": "var",
                        "name": "value"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "f"
                        }
                      ]
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "app",
                        "func": {
                          "tag": "type",
                          "name": "Decoder"
                        },
                        "args": [
                          {
                            "tag": "var",
                            "name": "g"
                          }
                        ]
                      },
                      "out": {
                        "tag": "app",
                        "func": {
                          "tag": "type",
                          "name": "Decoder"
                        },
                        "args": [
                          {
                            "tag": "var",
                            "name": "value"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "tuple8",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "var",
                      "name": "f"
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "var",
                        "name": "g"
                      },
                      "out": {
                        "tag": "lambda",
                        "in": {
                          "tag": "var",
                          "name": "h"
                        },
                        "out": {
                          "tag": "var",
                          "name": "value"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Decoder"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Decoder"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Decoder"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Decoder"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Decoder"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "lambda",
                    "in": {
                      "tag": "app",
                      "func": {
                        "tag": "type",
                        "name": "Decoder"
                      },
                      "args": [
                        {
                          "tag": "var",
                          "name": "f"
                        }
                      ]
                    },
                    "out": {
                      "tag": "lambda",
                      "in": {
                        "tag": "app",
                        "func": {
                          "tag": "type",
                          "name": "Decoder"
                        },
                        "args": [
                          {
                            "tag": "var",
                            "name": "g"
                          }
                        ]
                      },
                      "out": {
                        "tag": "lambda",
                        "in": {
                          "tag": "app",
                          "func": {
                            "tag": "type",
                            "name": "Decoder"
                          },
                          "args": [
                            {
                              "tag": "var",
                              "name": "h"
                            }
                          ]
                        },
                        "out": {
                          "tag": "app",
                          "func": {
                            "tag": "type",
                            "name": "Decoder"
                          },
                          "args": [
                            {
                              "tag": "var",
                              "name": "value"
                            }
                          ]
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "value",
      "comment": "Bring in an arbitrary JSON value. Useful if you need to work with crazily\nformatted data. For example, this lets you create a parser for \"variadic\" lists\nwhere the first few types are different, followed by 0 or more of the same\ntype.\n\n    variadic2 : (a -\u003e b -\u003e List c -\u003e value) -\u003e Decoder a -\u003e Decoder b -\u003e Decoder (List c) -\u003e Decoder value\n    variadic2 f a b cs =\n        customDecoder (list value) \\jsonList -\u003e\n            case jsonList of\n              one :: two :: rest -\u003e\n                  Result.map3 f\n                    (decodeValue a one)\n                    (decodeValue b two)\n                    (decodeValue cs rest)\n\n              _ -\u003e Result.Err \"expecting at least two elements in the array\"",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Decoder"
        },
        "args": [
          {
            "tag": "type",
            "name": "Value"
          }
        ]
      }
    }
  ]
}
,
{
  "name": "Json.Encode",
  "comment": "Library for turning Elm values into JSON values.\n\n# Encoding\n@docs encode\n\n# Primatives\n@docs string, int, float, bool, null\n\n# Arrays\n@docs list, array\n\n# Objects\n@docs object",
  "aliases": [],
  "types": [
    {
      "name": "Value",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Value",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "array",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Array"
          },
          "args": [
            {
              "tag": "type",
              "name": "Value"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Value"
        }
      }
    },
    {
      "name": "bool",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Bool"
        },
        "out": {
          "tag": "type",
          "name": "Value"
        }
      }
    },
    {
      "name": "encode",
      "comment": "Convert a `Value` into a prettified string. The first argument specifies\nthe amount of indentation in the resulting string.\n\n    person =\n        object\n          [ (\"name\", string \"Tom\")\n          , (\"age\", int 42)\n          ]\n\n    compact = encode 0 person\n    -- {\"name\":\"Tom\",\"age\":42}\n\n    readable = encode 4 person\n    -- {\n    --     \"name\": \"Tom\",\n    --     \"age\": 42\n    -- }",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Value"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "float",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Value"
        }
      }
    },
    {
      "name": "int",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "type",
          "name": "Value"
        }
      }
    },
    {
      "name": "list",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "Value"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Value"
        }
      }
    },
    {
      "name": "null",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Value"
      }
    },
    {
      "name": "object",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                },
                {
                  "tag": "type",
                  "name": "Value"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Value"
        }
      }
    },
    {
      "name": "string",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "Value"
        }
      }
    }
  ]
}
,
{
  "name": "Keyboard",
  "comment": "Library for working with keyboard input.\n\n# Representing Keys\n@docs KeyCode\n\n# Directions\n@docs arrows, wasd, directions\n\n# Specific Keys\nThe following signals are `True` when the particular key is pressed and `False`\notherwise.\n\n@docs enter, space, ctrl, shift, alt, meta\n\n# General Keypresses\n@docs isDown, keysDown, lastPressed",
  "aliases": [
    {
      "name": "KeyCode",
      "comment": "Type alias to make it clearer what integers are supposed to represent\nin this library. Use `Char.toCode` and `Char.fromCode` to convert key codes\nto characters. Use the uppercase character with `toCode`.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Int"
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "alt",
      "comment": "",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "arrows",
      "comment": "A signal of records indicating which arrow keys are pressed.\n\n  * `{ x = 0, y = 0 }` when pressing no arrows.\n  * `{ x =-1, y = 0 }` when pressing the left arrow.\n  * `{ x = 1, y = 1 }` when pressing the up and right arrows.\n  * `{ x = 0, y =-1 }` when pressing the down, left, and right arrows.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": [
              [
                "x",
                {
                  "tag": "type",
                  "name": "Int"
                }
              ],
              [
                "y",
                {
                  "tag": "type",
                  "name": "Int"
                }
              ]
            ]
          }
        ]
      }
    },
    {
      "name": "ctrl",
      "comment": "",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "directions",
      "comment": "Custom key directions to support different locales. The order is up, down,\nleft, right.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "KeyCode"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "KeyCode"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "KeyCode"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "KeyCode"
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Signal"
                },
                "args": [
                  {
                    "tag": "record",
                    "extension": null,
                    "fields": [
                      [
                        "x",
                        {
                          "tag": "type",
                          "name": "Int"
                        }
                      ],
                      [
                        "y",
                        {
                          "tag": "type",
                          "name": "Int"
                        }
                      ]
                    ]
                  }
                ]
              }
            }
          }
        }
      }
    },
    {
      "name": "enter",
      "comment": "",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "isDown",
      "comment": "Whether an arbitrary key is pressed.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "KeyCode"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "type",
              "name": "Bool"
            }
          ]
        }
      }
    },
    {
      "name": "keysDown",
      "comment": "List of keys that are currently down.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "KeyCode"
              }
            ]
          }
        ]
      }
    },
    {
      "name": "lastPressed",
      "comment": "The latest key that has been pressed.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "KeyCode"
          }
        ]
      }
    },
    {
      "name": "meta",
      "comment": "The meta key is the Windows key on Windows and the Command key on Mac.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "shift",
      "comment": "",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "space",
      "comment": "",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "wasd",
      "comment": "Just like the arrows signal, but this uses keys w, a, s, and d,\nwhich are common controls for many computer games.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": [
              [
                "x",
                {
                  "tag": "type",
                  "name": "Int"
                }
              ],
              [
                "y",
                {
                  "tag": "type",
                  "name": "Int"
                }
              ]
            ]
          }
        ]
      }
    }
  ]
}
,
{
  "name": "List",
  "comment": "A library for manipulating lists of values. Every value in a\nlist must have the same type.\n\n# Basics\n@docs isEmpty, length, reverse, member\n\n# Sub-lists\n@docs head, tail, filter, take, drop\n\n# Putting Lists Together\n@docs repeat, (::), append, concat, intersperse\n\n# Taking Lists Apart\n@docs partition, unzip\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\nIf you can think of a legitimate use of `mapN` where `N` is 6 or more, please\nlet us know on [the list](https://groups.google.com/forum/#!forum/elm-discuss).\nThe current sentiment is that it is already quite error prone once you get to\n4 and possibly should be approached another way.\n\n# Special Maps\n@docs filterMap, concatMap, indexedMap\n\n# Folding\n@docs foldr, foldl\n\n# Special Folds\n@docs sum, product, maximum, minimum, all, any, foldr1, foldl1, scanl, scanl1\n\n# Sorting\n@docs sort, sortBy, sortWith",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "::",
      "comment": "Add an element to the front of a list. Pronounced *cons*.\n\n    1 :: [2,3] == [1,2,3]\n    1 :: [] == [1]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      },
      "associativity": "right",
      "precedence": 5
    },
    {
      "name": "all",
      "comment": "Determine if all elements satisfy the predicate.\n\n    all isEven [2,4] == True\n    all isEven [2,3] == False\n    all isEven [] == True",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "any",
      "comment": "Determine if any elements satisfy the predicate.\n\n    any isEven [2,3] == True\n    any isEven [1,3] == False\n    any isEven [] == False",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "append",
      "comment": "Put two lists together.\n\n    append [1,1,2] [3,5,8] == [1,1,2,3,5,8]\n    append ['a','b'] ['c'] == ['a','b','c']",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "concat",
      "comment": "Concatenate a bunch of lists into a single list:\n\n    concat [[1,2],[3],[4,5]] == [1,2,3,4,5]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "concatMap",
      "comment": "Map a given function onto a list and flatten the resulting lists.\n\n    concatMap f xs == concat (map f xs)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "drop",
      "comment": "Drop the first *n* members of a list.\n\n    drop 2 [1,2,3,4] == [3,4]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "filter",
      "comment": "Keep only elements that satisfy the predicate.\n\n    filter isEven [1..6] == [2,4,6]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "filterMap",
      "comment": "Apply a function that may succeed to all values in the list, but only keep\nthe successes.\n\n    String.toInt : String -\u003e Maybe Int\n\n    filterMap String.toInt [\"3\", \"4.0\", \"5\", \"hats\"] == [3,5]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "foldl",
      "comment": "Reduce a list from the left.\n\n    foldl (::) [] [1,2,3] == [3,2,1]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "foldl1",
      "comment": "Reduce a list from the left without a base case. List must be non-empty.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "a"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "var",
            "name": "a"
          }
        }
      }
    },
    {
      "name": "foldr",
      "comment": "Reduce a list from the right.\n\n    foldr (+) 0 [1,2,3] == 6",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "foldr1",
      "comment": "Reduce a list from the right without a base case. List must be non-empty.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "a"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "var",
            "name": "a"
          }
        }
      }
    },
    {
      "name": "head",
      "comment": "Extract the first element of a list. List must be non-empty.\n\n    head [1,2,3] == 1",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "a"
        }
      }
    },
    {
      "name": "indexedMap",
      "comment": "Same as `map` but the function is also applied to the index of each\nelement (starting at zero).\n\n    indexedMap (,) [\"Tom\",\"Sue\",\"Bob\"] == [ (0,\"Tom\"), (1,\"Sue\"), (2,\"Bob\") ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "intersperse",
      "comment": "Places the given value between all members of the given list.\n\n    intersperse \"on\" [\"turtles\",\"turtles\",\"turtles\"] == [\"turtles\",\"on\",\"turtles\",\"on\",\"turtles\"]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "isEmpty",
      "comment": "Determine if a list is empty.\n\n    isEmpty [] == True",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "length",
      "comment": "Determine the length of a list.\n\n    length [1,2,3] == 3",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "map",
      "comment": "Apply a function to every element of a list.\n\n    map sqrt [1,4,9] == [1,2,3]\n\n    map not [True,False,True] == [False,True,False]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "map2",
      "comment": "Combine two lists, combining them with the given function.\nIf one list is longer, the extra elements are dropped.\n\n    map2 (+) [1,2,3] [1,2,3,4] == [2,4,6]\n\n    map2 (,) [1,2,3] ['a','b'] == [ (1,'a'), (2,'b') ]\n\n    pairs : List a -\u003e List b -\u003e List (a,b)\n    pairs lefts rights =\n        map2 (,) lefts rights",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "result"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "result"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "map3",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "var",
                "name": "result"
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "result"
                  }
                ]
              }
            }
          }
        }
      }
    },
    {
      "name": "map4",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "var",
                  "name": "result"
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "List"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "List"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "result"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "map5",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "var",
                    "name": "result"
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "List"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "List"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "List"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "result"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "maximum",
      "comment": "Find the maximum element in a non-empty list.\n\n    maximum [1,4,2] == 4",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "comparable"
        }
      }
    },
    {
      "name": "maybeCons",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "member",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "minimum",
      "comment": "Find the minimum element in a non-empty list.\n\n    minimum [3,2,1] == 1",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "comparable"
        }
      }
    },
    {
      "name": "partition",
      "comment": "Partition a list based on a predicate. The first list contains all values\nthat satisfy the predicate, and the second list contains all the value that do\nnot.\n\n    partition (\\x -\u003e x \u003c 3) [0..5] == ([0,1,2], [3,4,5])\n    partition isEven        [0..5] == ([0,2,4], [1,3,5])",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "a"
                  }
                ]
              },
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "a"
                  }
                ]
              }
            ]
          }
        }
      }
    },
    {
      "name": "product",
      "comment": "Get the product of the list elements.\n\n    product [1..4] == 24",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "number"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "number"
        }
      }
    },
    {
      "name": "repeat",
      "comment": "Create a list with *n* copies of a value:\n\n    repeat 3 (0,0) == [(0,0),(0,0),(0,0)]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "reverse",
      "comment": "Reverse a list.\n\n    reverse [1..4] == [4,3,2,1]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "scanl",
      "comment": "Reduce a list from the left, building up all of the intermediate results into a list.\n\n    scanl (+) 0 [1,2,3,4] == [0,1,3,6,10]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "scanl1",
      "comment": "Same as scanl but it doesn't require a base case. List must be non-empty.\n\n    scanl1 (+) [1,2,3,4] == [1,3,6,10]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "var",
              "name": "a"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "sort",
      "comment": "Sort values from lowest to highest\n\n    sort [3,1,5] == [1,3,5]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        }
      }
    },
    {
      "name": "sortBy",
      "comment": "Sort values by a derived property.\n\n    alice = { name=\"Alice\", height=1.62 }\n    bob   = { name=\"Bob\"  , height=1.85 }\n    chuck = { name=\"Chuck\", height=1.76 }\n\n    sortBy .name   [chuck,alice,bob] == [alice,bob,chuck]\n    sortBy .height [chuck,alice,bob] == [alice,chuck,bob]\n\n    sortBy String.length [\"mouse\",\"cat\"] == [\"cat\",\"mouse\"]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "comparable"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "sortWith",
      "comment": "Sort values with a custom comparison function.\n\n    sortWith flippedComparison [1..5] == [5,4,3,2,1]\n\n    flippedComparison a b =\n        case compare a b of\n          LT -\u003e GT\n          EQ -\u003e EQ\n          GT -\u003e LT\n\nThis is also the most general sort function, allowing you\nto define any other: `sort == sortWith compare`",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "type",
              "name": "Order"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "sum",
      "comment": "Get the sum of the list elements.\n\n    sum [1..4] == 10",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "number"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "number"
        }
      }
    },
    {
      "name": "tail",
      "comment": "Extract the elements after the head of the list. List must be non-empty.\n\n    tail [1,2,3] == [2,3]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "take",
      "comment": "Take the first *n* members of a list.\n\n    take 2 [1,2,3,4] == [1,2]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "unzip",
      "comment": "Decompose a list of tuples into a tuple of lists.\n\n    unzip [(0, True), (17, False), (1337, True)] == ([0,17,1337], [True,False,True])",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                },
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "_Tuple2"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          ]
        }
      }
    }
  ]
}
,
{
  "name": "Maybe",
  "comment": "This library fills a bunch of important niches in Elm. A `Maybe` can help\nyou with optional arguments, error handling, and records with optional fields.\n\n# Definition\n@docs Maybe\n\n# Common Helpers\n@docs map, withDefault, oneOf\n\n# Chaining Maybes\n@docs andThen",
  "aliases": [],
  "types": [
    {
      "name": "Maybe",
      "comment": "Represent values that may or may not exist. It can be useful if you have a\nrecord field that is only filled in sometimes. Or if a function takes a value\nsometimes, but does not absolutely need it.\n\n    -- A person, but maybe we do not know their age.\n    type alias Person =\n        { name : String\n        , age : Maybe Int\n        }\n\n    tom = { name = \"Tom\", age = Just 42 }\n    sue = { name = \"Sue\", age = Nothing }",
      "args": [
        "a"
      ],
      "cases": [
        [
          "Just",
          [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        ],
        [
          "Nothing",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "andThen",
      "comment": "Chain together many computations that may fail. It is helpful to see its\ndefinition:\n\n    andThen : Maybe a -\u003e (a -\u003e Maybe b) -\u003e Maybe b\n    andThen maybe callback =\n        case maybe of\n          Just value -\u003e callback value\n          Nothing -\u003e Nothing\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`toInt : String -\u003e Maybe Int`) to parse a month\nand make sure it is between 1 and 12:\n\n    toValidMonth : Int -\u003e Maybe Int\n    toValidMonth month =\n        if month \u003e= 1 && month \u003c= 12\n            then Just month\n            else Nothing\n\n    toMonth : String -\u003e Maybe Int\n    toMonth rawString =\n        toInt rawString `andThen` toValidMonth\n\nIf `toInt` fails and results in `Nothing` this entire chain of operations will\nshort-circuit and result in `Nothing`. If `toValidMonth` results in `Nothing`,\nagain the chain of computations will result in `Nothing`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Maybe"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "map",
      "comment": "Transform an `Maybe` value with a given function:\n\n    map sqrt (Just 9) == Just 3\n    map sqrt Nothing == Nothing",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "oneOf",
      "comment": "Pick the first `Maybe` that actually has a value. Useful when you want to\ntry a couple different things, but there is no default value.\n\n    oneOf [ Nothing, Just 42, Just 71 ] == Just 42\n    oneOf [ Nothing, Nothing, Just 71 ] == Just 71\n    oneOf [ Nothing, Nothing, Nothing ] == Nothing",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Maybe"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "withDefault",
      "comment": "Provide a default value, turning an optional value into a normal value.\nThis comes in handy when paired with functions like `Dict.get` which gives back\na `Maybe`.\n\n    withDefault 100 (Just 42)   -- 42\n    withDefault 100 Nothing     -- 100\n\n    withDefault \"unknown\" (Dict.get \"Tom\" Dict.empty)   -- \"unknown\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "var",
            "name": "a"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Mouse",
  "comment": "Library for working with mouse input.\n\n# Position\n@docs position, x, y\n\n# Button Status\n@docs isDown, clicks",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "clicks",
      "comment": "Always equal to unit. Event triggers on every mouse click.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple0"
            },
            "args": []
          }
        ]
      }
    },
    {
      "name": "isDown",
      "comment": "The current state of the left mouse-button.\nTrue when the button is down, and false otherwise.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Bool"
          }
        ]
      }
    },
    {
      "name": "position",
      "comment": "The current mouse position.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "type",
                "name": "Int"
              },
              {
                "tag": "type",
                "name": "Int"
              }
            ]
          }
        ]
      }
    },
    {
      "name": "x",
      "comment": "The current x-coordinate of the mouse.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Int"
          }
        ]
      }
    },
    {
      "name": "y",
      "comment": "The current y-coordinate of the mouse.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Int"
          }
        ]
      }
    }
  ]
}
,
{
  "name": "Random",
  "comment": "This library helps you generate pseudo-random values.\n\nThe general pattern is to define a `Generator` which can produce certain kinds\nof random values. You actually produce random values by feeding a fresh `Seed`\nto your `Generator`.\n\nSince you need a fresh `Seed` to produce more random values, you should\nprobably store a `Seed` in your application's state. This will allow you to\nkeep updating it as you generate random values and fresh seeds.\n\nThe following example models a bunch of bad guys that randomly appear. The\n`possiblyAddBadGuy` function uses the random seed to see if we should add a bad\nguy, and if so, it places a bad guy at a randomly generated point.\n\n    type alias Model =\n        { badGuys : List (Float,Float)\n        , seed : Seed\n        }\n\n    possiblyAddBadGuy : Model -\u003e Model\n    possiblyAddBadGuy model =\n        let (addProbability, seed') =\n              generate (float 0 1) model.seed\n        in\n            if addProbability \u003c 0.9\n              then\n                { model |\n                    seed \u003c- seed'\n                }\n              else\n                let (position, seed'') =\n                      generate (pair (float 0 100) (float 0 100)) seed'\n                in\n                    { model |\n                        badGuys \u003c- position :: model.badGuys\n                        seed \u003c- seed''\n                    }\n\nDetails: This is an implemenation of the Portable Combined Generator of\nL'Ecuyer for 32-bit computers. It is almost a direct translation from the\n[System.Random](http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html)\nmodule. It has a period of roughly 2.30584e18.\n\n# Generators\n\n@docs int, float, pair, list\n\n# Running a Generator\n\n@docs generate, initialSeed\n\n# Constants\n\n@docs maxInt, minInt\n\n# Custom Generators\n\n@docs customGenerator",
  "aliases": [
    {
      "name": "Seed",
      "comment": "",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "state",
            {
              "tag": "type",
              "name": "State"
            }
          ],
          [
            "next",
            {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "State"
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "_Tuple2"
                },
                "args": [
                  {
                    "tag": "type",
                    "name": "Int"
                  },
                  {
                    "tag": "type",
                    "name": "State"
                  }
                ]
              }
            }
          ],
          [
            "split",
            {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "State"
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "_Tuple2"
                },
                "args": [
                  {
                    "tag": "type",
                    "name": "State"
                  },
                  {
                    "tag": "type",
                    "name": "State"
                  }
                ]
              }
            }
          ],
          [
            "range",
            {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "State"
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "_Tuple2"
                },
                "args": [
                  {
                    "tag": "type",
                    "name": "Int"
                  },
                  {
                    "tag": "type",
                    "name": "Int"
                  }
                ]
              }
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "customGenerator",
      "comment": "Create a custom generator. You provide a function that takes a seed, and\nreturns a random value and a new seed. You can use this to create custom\ngenerators not covered by the basic functions in this library.\n\n    pairOf : Generator a -\u003e Generator (a,a)\n    pairOf generator =\n      customGenerator \u003c| \\seed -\u003e\n        let (left , seed' ) = generate generator seed\n            (right, seed'') = generate generator seed'\n        in\n            ((left,right), seed'')",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Seed"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              },
              {
                "tag": "type",
                "name": "Seed"
              }
            ]
          }
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Generator"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "float",
      "comment": "Create a generator that produces floats in a given range.\n\n    probability : Generator Float\n    probability =\n        float 0 1\n\n    -- generate probability seed0 ==\u003e (0.51, seed1)\n    -- generate probability seed1 ==\u003e (0.04, seed2)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Generator"
            },
            "args": [
              {
                "tag": "type",
                "name": "Float"
              }
            ]
          }
        }
      }
    },
    {
      "name": "generate",
      "comment": "Run a random value generator with a given seed. It will give you back a\nrandom value and a new seed.\n\n    seed0 = initialSeed 31415\n\n    -- generate (int 0 100) seed0 ==\u003e (42, seed1)\n    -- generate (int 0 100) seed1 ==\u003e (31, seed2)\n    -- generate (int 0 100) seed2 ==\u003e (99, seed3)\n\nNotice that we use different seeds on each line. This is important! If you use\nthe same seed, you get the same results.\n\n    -- generate (int 0 100) seed0 ==\u003e (42, seed1)\n    -- generate (int 0 100) seed0 ==\u003e (42, seed1)\n    -- generate (int 0 100) seed0 ==\u003e (42, seed1)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Generator"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Seed"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              },
              {
                "tag": "type",
                "name": "Seed"
              }
            ]
          }
        }
      }
    },
    {
      "name": "initialSeed",
      "comment": "Create a &ldquo;seed&rdquo; of randomness which makes it possible to\ngenerate random values. If you use the same seed many times, it will result\nin the same thing every time! A good way to get an unexpected seed is to use\nthe current time.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "type",
          "name": "Seed"
        }
      }
    },
    {
      "name": "int",
      "comment": "Create a generator that produces 32-bit integers in a given range. This\nfunction *can* produce values outside of the range [minInt, maxInt] but\nsufficient randomness is not guaranteed.\n\n    int 0 10   -- an integer between zero and ten\n    int -5 5   -- an integer between -5 and 5\n\n    int minInt maxInt  -- an integer in the widest range feasible",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Generator"
            },
            "args": [
              {
                "tag": "type",
                "name": "Int"
              }
            ]
          }
        }
      }
    },
    {
      "name": "list",
      "comment": "Create a list of random values.\n\n    floatList : Generator (List Float)\n    floatList =\n        list 10 (float 0 1)\n\n    intList : Generator (List Int)\n    intList =\n        list 5 (int 0 100)\n\n    intPairs : Generator (List (Int, Int))\n    intPairs =\n        list 10 (pair int int)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Generator"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Generator"
            },
            "args": [
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "List"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "a"
                  }
                ]
              }
            ]
          }
        }
      }
    },
    {
      "name": "maxInt",
      "comment": "The maximum value for randomly generated 32-bit ints.",
      "type": {
        "tag": "type",
        "name": "Int"
      }
    },
    {
      "name": "minInt",
      "comment": "The minimum value for randomly generated 32-bit ints.",
      "type": {
        "tag": "type",
        "name": "Int"
      }
    },
    {
      "name": "pair",
      "comment": "Create a pair of random values. A common use of this might be to generate\na point in a certain 2D space. Imagine we have a collage that is 400 pixels\nwide and 200 pixels tall.\n\n    randomPoint : Generator (Int,Int)\n    randomPoint =\n        pair (int -200 200) (int -100 100)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Generator"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Generator"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Generator"
            },
            "args": [
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "_Tuple2"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "a"
                  },
                  {
                    "tag": "var",
                    "name": "b"
                  }
                ]
              }
            ]
          }
        }
      }
    }
  ]
}
,
{
  "name": "Regex",
  "comment": "A library for working with regular expressions. It uses [the\nsame kind of regular expressions accepted by JavaScript](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions).\n\n# Create\n@docs regex, escape, caseInsensitive\n\n# Helpful Data Structures\n\nThese data structures are needed to help define functions like [`find`](#find)\nand [`replace`](#replace).\n\n@docs HowMany, Match\n\n# Use\n@docs contains, find, replace, split",
  "aliases": [
    {
      "name": "Match",
      "comment": "A `Match` represents all of the details about a particular match in a string.\nHere are details on each field:\n\n  * `match` &mdash; the full string of the match.\n  * `submatches` &mdash; a regex might have [subpatterns, surrounded by\n    parentheses](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions#Using_Parenthesized_Substring_Matches).\n    If there are N subpatterns, there will be N elements in the `submatches` list.\n    Each submatch in this list is a `Maybe` because not all subpatterns may trigger.\n    For example, `(regex \"(a+)|(b+)\")` will either match many `a`&rsquo;s or\n    many `b`&rsquo;s, but never both.\n  * `index` &mdash; the index of the match in the original string.\n  * `number` &mdash; if you find many matches, you can think of each one\n    as being labeled with a `number` starting at one. So the first time you\n    find a match, that is match `number` one. Second time is match `number` two.\n    This is useful when paired with `replace All` if replacement is dependent on how\n    many times a pattern has appeared before.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "match",
            {
              "tag": "type",
              "name": "String"
            }
          ],
          [
            "submatches",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Maybe"
                  },
                  "args": [
                    {
                      "tag": "type",
                      "name": "String"
                    }
                  ]
                }
              ]
            }
          ],
          [
            "index",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "number",
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        ]
      }
    }
  ],
  "types": [
    {
      "name": "HowMany",
      "comment": "`HowMany` is used to specify how many matches you want to make. So\n`replace All` would replace every match, but `replace (AtMost 2)` would\nreplace at most two matches (i.e. zero, one, two, but never three or more).",
      "args": [],
      "cases": [
        [
          "All",
          []
        ],
        [
          "AtMost",
          [
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        ]
      ]
    },
    {
      "name": "Regex",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Regex",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "caseInsensitive",
      "comment": "Make a regex case insensitive",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Regex"
        },
        "out": {
          "tag": "type",
          "name": "Regex"
        }
      }
    },
    {
      "name": "contains",
      "comment": "Check to see if a Regex is contained in a string.\n\n    contains (regex \"123\") \"12345\" == True\n    contains (regex \"b+\") \"aabbcc\" == True\n\n    contains (regex \"789\") \"12345\" == False\n    contains (regex \"z+\") \"aabbcc\" == False",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Regex"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "escape",
      "comment": "Escape strings to be regular expressions, making all special characters\nsafe. So `regex (escape \"^a+\")` will match exactly `\"^a+\"` instead of a series\nof `a`&rsquo;s that start at the beginning of the line.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "find",
      "comment": "Find matches in a string:\n\n    findTwoCommas = find (AtMost 2) (regex \",\")\n\n      -- map .index (findTwoCommas \"a,b,c,d,e\") == [1,3]\n      -- map .index (findTwoCommas \"a b c d e\") == []\n\n    places = find All (regex \"[oi]n a (\\\\w+)\") \"I am on a boat in a lake.\"\n\n      -- map .match places == [\"on a boat\", \"in a lake\"]\n      -- map .submatches places == [ [Just \"boat\"], [Just \"lake\"] ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "HowMany"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Regex"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Match"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "regex",
      "comment": "Create a Regex that matches patterns [as specified in JavaScript](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions#Writing_a_Regular_Expression_Pattern).\n\nBe careful to escape backslashes properly! For example, `\"\\w\"` is escaping the\nletter `w` which is probably not what you want. You probably want `\"\\\\w\"`\ninstead, which escapes the backslash.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "Regex"
        }
      }
    },
    {
      "name": "replace",
      "comment": "Replace matches. The function from `Match` to `String` lets\nyou use the details of a specific match when making replacements.\n\n    devowel = replace All (regex \"[aeiou]\") (\\_ -\u003e \"\")\n\n      -- devowel \"The quick brown fox\" == \"Th qck brwn fx\"\n\n    reverseWords = replace All (regex \"\\\\w+\") (\\{match} -\u003e String.reverse match)\n\n      -- reverseWords \"deliver mined parts\" == \"reviled denim strap\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "HowMany"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Regex"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Match"
              },
              "out": {
                "tag": "type",
                "name": "String"
              }
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "String"
              },
              "out": {
                "tag": "type",
                "name": "String"
              }
            }
          }
        }
      }
    },
    {
      "name": "split",
      "comment": "Split a string, using the regex as the separator.\n\n    split (AtMost 1) (regex \",\") \"tom,99,90,85\" == [\"tom\",\"99,90,85\"]\n\n    split All (regex \",\") \"a,b,c,d\" == [\"a\",\"b\",\"c\",\"d\"]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "HowMany"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Regex"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            }
          }
        }
      }
    }
  ]
}
,
{
  "name": "Result",
  "comment": "A `Result` is the result of a computation that may fail. This is a great\nway to manage errors in Elm.\n\n# Type and Constructors\n@docs Result\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\n# Chaining\n@docs andThen\n\n# Formatting Errors\n@docs toMaybe, fromMaybe, formatError",
  "aliases": [],
  "types": [
    {
      "name": "Result",
      "comment": "A `Result` is either `Ok` meaning the computation succeeded, or it is an\n`Err` meaning that there was some failure.",
      "args": [
        "error",
        "value"
      ],
      "cases": [
        [
          "Ok",
          [
            {
              "tag": "var",
              "name": "value"
            }
          ]
        ],
        [
          "Err",
          [
            {
              "tag": "var",
              "name": "error"
            }
          ]
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "andThen",
      "comment": "Chain together a sequence of computations that may fail. It is helpful\nto see its definition:\n\n    andThen : Result e a -\u003e (a -\u003e Result e b) -\u003e Result e b\n    andThen result callback =\n        case result of\n          Ok value -\u003e callback value\n          Err msg -\u003e Err msg\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`toInt : String -\u003e Result String Int`) to parse\na month and make sure it is between 1 and 12:\n\n    toValidMonth : Int -\u003e Result String Int\n    toValidMonth month =\n        if month \u003e= 1 && month \u003c= 12\n            then Ok month\n            else Err \"months must be between 1 and 12\"\n\n    toMonth : String -\u003e Result String Int\n    toMonth rawString =\n        toInt rawString `andThen` toValidMonth\n\n    -- toMonth \"4\" == Ok 4\n    -- toMonth \"9\" == Ok 9\n    -- toMonth \"a\" == Err \"cannot parse to an Int\"\n    -- toMonth \"0\" == Err \"months must be between 1 and 12\"\n\nThis allows us to come out of a chain of operations with quite a specific error\nmessage. It is often best to create a custom type that explicitly represents\nthe exact ways your computation may fail. This way it is easy to handle in your\ncode.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Result"
          },
          "args": [
            {
              "tag": "var",
              "name": "x"
            },
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "a"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Result"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "x"
                },
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            }
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "formatError",
      "comment": "Format the error value of a result. If the result is `Ok`, it stays exactly\nthe same, but if the result is an `Err` we will format the error. For example,\nsay the errors we get have too much information:\n\n    parseInt : String -\u003e Result ParseError Int\n\n    type ParseError =\n        { message : String\n        , code : Int\n        , position : (Int,Int)\n        }\n\n    formatError .message (parseInt \"123\") == Ok 123\n    formatError .message (parseInt \"abc\") == Err \"char 'a' is not a number\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "error"
          },
          "out": {
            "tag": "var",
            "name": "error'"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "error"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "error'"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "fromMaybe",
      "comment": "Convert from a simple `Maybe` to interact with some code that primarily\nuses `Results`.\n\n    parseInt : String -\u003e Maybe Int\n\n    resultParseInt : String -\u003e Result String Int\n    resultParseInt string =\n        fromMaybe (\"error parsing string: \" ++ toString string) (parseInt string)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "x"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Maybe"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "map",
      "comment": "Apply a function to a result. If the result is `Ok`, it will be converted.\nIf the result is an `Err`, the same error value will propagate through.\n\n    map sqrt (Ok 4.0)          == Ok 2.0\n    map sqrt (Err \"bad input\") == Err \"bad input\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "value"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "value"
              }
            ]
          }
        }
      }
    },
    {
      "name": "map2",
      "comment": "Apply a function to two results, if both results are `Ok`. If not,\nthe first argument which is an `Err` will propagate through.\n\n    map2 (+) (String.toInt \"1\") (String.toInt \"2\") == Ok 3\n    map2 (+) (String.toInt \"1\") (String.toInt \"y\") == Err \"could not convert string 'y' to an Int\"\n    map2 (+) (String.toInt \"x\") (String.toInt \"y\") == Err \"could not convert string 'x' to an Int\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "value"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Result"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "x"
                },
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Result"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "x"
                },
                {
                  "tag": "var",
                  "name": "value"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "map3",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "var",
                "name": "value"
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Result"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "x"
                },
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Result"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "x"
                  },
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Result"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "x"
                  },
                  {
                    "tag": "var",
                    "name": "value"
                  }
                ]
              }
            }
          }
        }
      }
    },
    {
      "name": "map4",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "var",
                  "name": "value"
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Result"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "x"
                },
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Result"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "x"
                  },
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Result"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "x"
                    },
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Result"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "x"
                    },
                    {
                      "tag": "var",
                      "name": "value"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "map5",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "var",
                    "name": "value"
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Result"
            },
            "args": [
              {
                "tag": "var",
                "name": "x"
              },
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Result"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "x"
                },
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Result"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "x"
                  },
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Result"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "x"
                    },
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Result"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "x"
                      },
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Result"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "x"
                      },
                      {
                        "tag": "var",
                        "name": "value"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "toMaybe",
      "comment": "Convert to a simpler `Maybe` if the actual error message is not needed or\nyou need to interact with some code that primarily uses maybes.\n\n    parseInt : String -\u003e Result ParseError Int\n\n    maybeParseInt : String -\u003e Maybe Int\n    maybeParseInt string =\n        toMaybe (parseInt string)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Result"
          },
          "args": [
            {
              "tag": "var",
              "name": "x"
            },
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Maybe"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    }
  ]
}
,
{
  "name": "Set",
  "comment": "A set of unique values. The values can be any comparable type. This\nincludes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or lists\nof comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time. Set equality with\n`(==)` is unreliable and should not be used.\n\n# Build\n@docs empty, singleton, insert, remove\n\n# Query\n@docs member\n\n# Combine\n@docs union, intersect, diff\n\n# Lists\n@docs toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition",
  "aliases": [
    {
      "name": "Set",
      "comment": "",
      "args": [
        "t"
      ],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Dict.Dict"
        },
        "args": [
          {
            "tag": "var",
            "name": "t"
          },
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple0"
            },
            "args": []
          }
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "diff",
      "comment": "Get the difference between the first set and the second. Keeps values\nthat do not appear in the second set.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Set"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          }
        }
      }
    },
    {
      "name": "empty",
      "comment": "Create an empty set.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Set"
        },
        "args": [
          {
            "tag": "var",
            "name": "comparable"
          }
        ]
      }
    },
    {
      "name": "filter",
      "comment": "Create a new set consisting only of elements which satisfy a predicate.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          }
        }
      }
    },
    {
      "name": "foldl",
      "comment": "Fold over the values in a set, in order from lowest to highest.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Set"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "foldr",
      "comment": "Fold over the values in a set, in order from highest to lowest.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Set"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "comparable"
                }
              ]
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "fromList",
      "comment": "Convert a list into a set, removing any duplicates.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Set"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        }
      }
    },
    {
      "name": "insert",
      "comment": "Insert a value into a set.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          }
        }
      }
    },
    {
      "name": "intersect",
      "comment": "Get the intersection of two sets. Keeps values that appear in both sets.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Set"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          }
        }
      }
    },
    {
      "name": "map",
      "comment": "Map a function onto a set, creating a new set with no duplicates.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "var",
            "name": "comparable'"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable'"
              }
            ]
          }
        }
      }
    },
    {
      "name": "member",
      "comment": "Determine if a value is in a set.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "partition",
      "comment": "Create two new sets; the first consisting of elements which satisfy a\npredicate, the second consisting of elements which do not.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "comparable"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Set"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "comparable"
                  }
                ]
              },
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Set"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "comparable"
                  }
                ]
              }
            ]
          }
        }
      }
    },
    {
      "name": "remove",
      "comment": "Remove a value from a set. If the value is not found, no changes are made.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          }
        }
      }
    },
    {
      "name": "singleton",
      "comment": "Create a set with one value.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "comparable"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Set"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        }
      }
    },
    {
      "name": "toList",
      "comment": "Convert a set into a list.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Set"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        }
      }
    },
    {
      "name": "union",
      "comment": "Get the union of two sets. Keep all values.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Set"
          },
          "args": [
            {
              "tag": "var",
              "name": "comparable"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Set"
            },
            "args": [
              {
                "tag": "var",
                "name": "comparable"
              }
            ]
          }
        }
      }
    }
  ]
}
,
{
  "name": "Signal",
  "comment": "The library for general signal manipulation. Includes mapping, merging,\nfilters, past-dependence, and helpers for handling inputs from the UI.\n\nSome useful functions for working with time (e.g. setting FPS) and combining\nsignals and time (e.g.  delaying updates, getting timestamps) can be found in\nthe [`Time`](Time) library.\n\n# Merging\n@docs merge, mergeMany\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\n# Fancy Mapping\n@docs (\u003c~), (~)\n\n# Past-Dependence\n@docs foldp\n\n# Filters\n@docs keepIf, dropIf, keepWhen, dropWhen, dropRepeats, sampleOn\n\n# Channels\n@docs channel, send, subscribe\n\n# Constants\n@docs constant",
  "aliases": [],
  "types": [
    {
      "name": "Message",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Message",
          []
        ]
      ]
    },
    {
      "name": "Channel",
      "comment": "",
      "args": [
        "a"
      ],
      "cases": [
        [
          "Channel",
          []
        ]
      ]
    },
    {
      "name": "Signal",
      "comment": "",
      "args": [
        "a"
      ],
      "cases": [
        [
          "Signal",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "\u003c~",
      "comment": "An alias for `map`. A prettier way to apply a function to the current value\nof a signal.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "b"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      },
      "associativity": "left",
      "precedence": 4
    },
    {
      "name": "channel",
      "comment": "Create a signal channel that you can `send` messages to. To receive these\nmessages, `subscribe` to the channel and turn it into a normal signal. The\nprimary use case is receiving updates from UI elements such as buttons and\ntext fields. The argument is a default value for the custom signal.\n\nNote: This is an inherently impure function, so `(channel ())`\nand `(channel ())` produce two different channels.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Channel"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "constant",
      "comment": "Create a constant signal that never changes.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "dropIf",
      "comment": "Filter out some updates. The given function decides whether we should\ndrop an update. If we drop all updates, we use the default value provided.\nThe following example drops all even numbers and has an initial value of\none.\n\n    numbers : Signal Int\n\n    isEven : Int -\u003e Bool\n\n    odds : Signal Int\n    odds =\n        dropIf isEven 1 numbers",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "dropRepeats",
      "comment": "Drop updates that repeat the current value of the signal.\n\n    numbers : Signal Int\n\n    noDups : Signal Int\n    noDups =\n        dropRepeats numbers\n\n    --  numbers =\u003e 0 0 3 3 5 5 5 4 ...\n    --  noDups  =\u003e 0   3   5     4 ...\n\nThe signal should not be a signal of functions, or a record that contains a\nfunction (you'll get a runtime error since functions cannot be equated).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "dropWhen",
      "comment": "Drop events when the first signal is true. You provide a default value\njust in case that signal is *always* true and we drop all updates.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "type",
              "name": "Bool"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "foldp",
      "comment": "Create a past-dependent signal. Each update from the incoming signals will\nbe used to step the state forward. The outgoing signal represents the current\nstate.\n\n    clickCount : Signal Int\n    clickCount =\n        foldp (\\click total -\u003e total + 1) 0 Mouse.clicks\n\n    timeSoFar : Signal Time\n    timeSoFar =\n        foldp (+) 0 (fps 40)\n\nSo `clickCount` updates on each mouse click, incrementing by one. `timeSoFar`\nis the time the program has been running, updated 40 times a second.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "state"
            },
            "out": {
              "tag": "var",
              "name": "state"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "state"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "state"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "keepIf",
      "comment": "Filter out some updates. The given function decides whether we should\nkeep an update. If no updates ever flow through, we use the default value\nprovided. The following example only keeps even numbers and has an initial\nvalue of zero.\n\n    numbers : Signal Int\n\n    isEven : Int -\u003e Bool\n\n    evens : Signal Int\n    evens =\n        keepIf isEven 0 numbers",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "keepWhen",
      "comment": "Keep updates when the first signal is true. You provide a default value\njust in case that signal is *never* true and no updates make it through. For\nexample, here is how you would capture mouse drags.\n\n    dragPosition : Signal (Int,Int)\n    dragPosition =\n        keepWhen Mouse.isDown (0,0) Mouse.position",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "type",
              "name": "Bool"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "map",
      "comment": "Apply a function to the current value of a signal.\n\n    mouseIsUp : Signal Bool\n    mouseIsUp =\n        map not Mouse.isDown\n\n    main : Signal Element\n    main =\n        map toElement Mouse.position",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "var",
            "name": "result"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "result"
              }
            ]
          }
        }
      }
    },
    {
      "name": "map2",
      "comment": "Apply a function to the current value of two signals. The function is\nreevaluated whenever *either* signal changes. In the following example, we\nfigure out the `aspectRatio` of the window by combining the current width and\nheight.\n\n    ratio : Int -\u003e Int -\u003e Float\n    ratio width height =\n        toFloat width / toFloat height\n\n    aspectRatio : Signal Float\n    aspectRatio =\n        map2 ratio Window.width Window.height",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "result"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "result"
                }
              ]
            }
          }
        }
      }
    },
    {
      "name": "map3",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "var",
                "name": "result"
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Signal"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Signal"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "result"
                  }
                ]
              }
            }
          }
        }
      }
    },
    {
      "name": "map4",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "var",
                  "name": "result"
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Signal"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Signal"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Signal"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "result"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "map5",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "c"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "var",
                  "name": "d"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "var",
                    "name": "e"
                  },
                  "out": {
                    "tag": "var",
                    "name": "result"
                  }
                }
              }
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "b"
                }
              ]
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Signal"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "c"
                  }
                ]
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "app",
                  "func": {
                    "tag": "type",
                    "name": "Signal"
                  },
                  "args": [
                    {
                      "tag": "var",
                      "name": "d"
                    }
                  ]
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Signal"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "e"
                      }
                    ]
                  },
                  "out": {
                    "tag": "app",
                    "func": {
                      "tag": "type",
                      "name": "Signal"
                    },
                    "args": [
                      {
                        "tag": "var",
                        "name": "result"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "merge",
      "comment": "Merge two signals into one. This function is extremely useful for bringing\ntogether lots of different signals to feed into a `foldp`.\n\n    type Update = MouseMove (Int,Int) | TimeDelta Float\n\n    updates : Signal Update\n    updates =\n        merge\n            (map MouseMove Mouse.position)\n            (map TimeDelta (fps 40))\n\nIf an update comes from either of the incoming signals, it updates the outgoing\nsignal. If an update comes on both signals at the same time, the left update\nwins (i.e., the right update is discarded).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "mergeMany",
      "comment": "Merge many signals into one. This is useful when you are merging more than\ntwo signals. When multiple updates come in at the same time, the left-most\nupdate wins, just like with `merge`.\n\n    type Update = MouseMove (Int,Int) | TimeDelta Float | Click\n\n    updates : Signal Update\n    updates =\n        mergeMany\n            [ map MouseMove Mouse.position\n            , map TimeDelta (fps 40)\n            , map (always Click) Mouse.clicks\n            ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Signal"
              },
              "args": [
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "sampleOn",
      "comment": "Sample from the second input every time an event occurs on the first input.\nFor example, `(sampleOn Mouse.clicks (Time.every Time.second))` will give the\napproximate time of the latest click.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      }
    },
    {
      "name": "send",
      "comment": "Create a `Message` that can be sent to a `Channel` with a handler like\n`Html.onclick` or `Html.onblur`. This doesn't actually send the message; it just\ncreates the message to be sent.\n\n    import Html\n\n    type Update = NoOp | Add Int | Remove Int\n\n    updates : Channel Update\n    updates = channel NoOp\n\n    addButton : Html.Html\n    addButton =\n        Html.button\n            [ onclick (send updates (Add 1)) ]\n            [ Html.text \"Add 1\" ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Channel"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "a"
          },
          "out": {
            "tag": "type",
            "name": "Message"
          }
        }
      }
    },
    {
      "name": "subscribe",
      "comment": "Receive all the messages sent to a `Channel` as a `Signal`. The following\nexample shows how you would set up a system that uses a `Channel`.\n\n    -- initialState : Model\n    -- type Update = NoOp | ...\n    -- step : Update -\u003e Model -\u003e Model\n    -- view : Channel Update -\u003e Model -\u003e Element\n\n    updates : Channel Update\n    updates = channel NoOp\n\n    main : Signal Element\n    main =\n      map\n        (view updates)\n        (foldp step initialState (subscribe updates))\n\nThe `updates` channel appears twice in `main` because it serves as a bridge\nbetween your view and your signals. In the view you `send` to it, and in signal\nworld you `subscribe` to it.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Channel"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        }
      }
    },
    {
      "name": "~",
      "comment": "Intended to be paired with the `(\u003c~)` operator, this makes it possible for\nmany signals to flow into a function. Think of it as a fancy alias for `mapN`.\nFor example, the following declarations are equivalent:\n\n    main : Signal Element\n    main =\n      scene \u003c~ Window.dimensions ~ Mouse.position\n\n    main : Signal Element\n    main =\n      map2 scene Window.dimensions Mouse.position\n\nYou can use this pattern for as many signals as you want by using `(~)` a bunch\nof times, so you can go higher than `map5` if you need to.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "lambda",
              "in": {
                "tag": "var",
                "name": "a"
              },
              "out": {
                "tag": "var",
                "name": "b"
              }
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "b"
              }
            ]
          }
        }
      },
      "associativity": "left",
      "precedence": 4
    }
  ]
}
,
{
  "name": "String",
  "comment": "A built-in representation for efficient string manipulation. String literals\nare enclosed in `\"double quotes\"`. Strings are *not* lists of characters.\n\n# Basics\n@docs isEmpty, length, reverse, repeat\n\n# Building and Splitting\n@docs cons, uncons, fromChar, append, concat, split, join, words, lines\n\n# Get Substrings\n@docs slice, left, right, dropLeft, dropRight\n\n# Check for Substrings\n@docs contains, startsWith, endsWith, indexes, indices\n\n# Conversions\n@docs toInt, toFloat, toList, fromList\n\n# Formatting\nCosmetic operations such as padding with extra characters or trimming whitespace.\n\n@docs toUpper, toLower,\n      pad, padLeft, padRight,\n      trim, trimLeft, trimRight\n\n# Higher-Order Functions\n@docs map, filter, foldl, foldr, any, all",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "all",
      "comment": "Determine whether *all* characters satisfy a predicate.\n\n    all isDigit \"90210\" == True\n    all isDigit \"R2-D2\" == False\n    all isDigit \"heart\" == False",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "any",
      "comment": "Determine whether *any* characters satisfy a predicate.\n\n    any isDigit \"90210\" == True\n    any isDigit \"R2-D2\" == True\n    any isDigit \"heart\" == False",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "append",
      "comment": "Append two strings. You can also use [the `(++)` operator](Basics#++)\nto do this.\n\n    append \"butter\" \"fly\" == \"butterfly\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "concat",
      "comment": "Concatenate many strings into one.\n\n    concat [\"never\",\"the\",\"less\"] == \"nevertheless\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "cons",
      "comment": "Add a character to the beginning of a string.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "contains",
      "comment": "See if the second string contains the first one.\n\n    contains \"the\" \"theory\" == True\n    contains \"hat\" \"theory\" == False\n    contains \"THE\" \"theory\" == False\n\nUse `Regex.contains` if you need something more flexible.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "dropLeft",
      "comment": "Drop *n* characters from the left side of a string.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "dropRight",
      "comment": "Drop *n* characters from the right side of a string.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "endsWith",
      "comment": "See if the second string ends with the first one.\n\n    endsWith \"the\" \"theory\" == False\n    endsWith \"ory\" \"theory\" == True",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "filter",
      "comment": "Keep only the characters that satisfy the predicate.\n\n    filter isDigit \"R2-D2\" == \"22\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "foldl",
      "comment": "Reduce a string from the left.\n\n    foldl cons \"\" \"time\" == \"emit\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "foldr",
      "comment": "Reduce a string from the right.\n\n    foldr cons \"\" \"time\" == \"time\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "var",
              "name": "b"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "var",
            "name": "b"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "var",
              "name": "b"
            }
          }
        }
      }
    },
    {
      "name": "fromChar",
      "comment": "Create a string from a given character.\n\n    fromChar 'a' == \"a\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Char"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "fromList",
      "comment": "Convert a list of characters into a String. Can be useful if you\nwant to create a string primarly by consing, perhaps for decoding\nsomething.\n\n    fromList ['a','b','c'] == \"abc\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "Char"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "indexes",
      "comment": "Get all of the indexes for a substring in another string.\n\n    indexes \"i\" \"Mississippi\"   == [1,4,7,10]\n    indexes \"ss\" \"Mississippi\"  == [2,5]\n    indexes \"needle\" \"haystack\" == []",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "Int"
              }
            ]
          }
        }
      }
    },
    {
      "name": "indices",
      "comment": "Alias for `indexes`.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "Int"
              }
            ]
          }
        }
      }
    },
    {
      "name": "isEmpty",
      "comment": "Determine if a string is empty.\n\n    isEmpty \"\" == True\n    isEmpty \"the world\" == False",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "Bool"
        }
      }
    },
    {
      "name": "join",
      "comment": "Put many strings together with a given separator.\n\n    join \"a\" [\"H\",\"w\",\"ii\",\"n\"]        == \"Hawaiian\"\n    join \" \" [\"cat\",\"dog\",\"cow\"]       == \"cat dog cow\"\n    join \"/\" [\"home\",\"evan\",\"Desktop\"] == \"home/evan/Desktop\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "left",
      "comment": "Take *n* characters from the left side of a string.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "length",
      "comment": "Get the length of a string.\n\n    length \"innumerable\" == 11\n    length \"\" == 0",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "Int"
        }
      }
    },
    {
      "name": "lines",
      "comment": "Break a string into lines, splitting on newlines.\n\n    lines \"How are you?\\nGood?\" == [\"How are you?\", \"Good?\"]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        }
      }
    },
    {
      "name": "map",
      "comment": "Transform every character in a string\n\n    map (\\c -\u003e if c == '/' then '.' else c) \"a/b/c\" == \"a.b.c\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "type",
            "name": "Char"
          }
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "pad",
      "comment": "Pad a string on both sides until it has a given length.\n\n    pad 5 ' ' \"1\"   == \"  1  \"\n    pad 5 ' ' \"11\"  == \"  11 \"\n    pad 5 ' ' \"121\" == \" 121 \"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    },
    {
      "name": "padLeft",
      "comment": "Pad a string on the left until it has a given length.\n\n    padLeft 5 '.' \"1\"   == \"....1\"\n    padLeft 5 '.' \"11\"  == \"...11\"\n    padLeft 5 '.' \"121\" == \"..121\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    },
    {
      "name": "padRight",
      "comment": "Pad a string on the right until it has a given length.\n\n    padRight 5 '.' \"1\"   == \"1....\"\n    padRight 5 '.' \"11\"  == \"11...\"\n    padRight 5 '.' \"121\" == \"121..\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Char"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    },
    {
      "name": "repeat",
      "comment": "Repeat a string *n* times.\n\n    repeat 3 \"ha\" == \"hahaha\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "reverse",
      "comment": "Reverse a string.\n\n    reverse \"stressed\" == \"desserts\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "right",
      "comment": "Take *n* characters from the right side of a string.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "slice",
      "comment": "Take a substring given a start and end index. Negative indexes\nare taken starting from the *end* of the list.\n\n    slice  7  9 \"snakes on a plane!\" == \"on\"\n    slice  0  6 \"snakes on a plane!\" == \"snakes\"\n    slice  0 -7 \"snakes on a plane!\" == \"snakes on a\"\n    slice -6 -1 \"snakes on a plane!\" == \"plane\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Int"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Int"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    },
    {
      "name": "split",
      "comment": "Split a string using a given separator.\n\n    split \",\" \"cat,dog,cow\"        == [\"cat\",\"dog\",\"cow\"]\n    split \"/\" \"home/evan/Desktop/\" == [\"home\",\"evan\",\"Desktop\", \"\"]\n\nUse `Regex.split` if you need something more flexible.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              }
            ]
          }
        }
      }
    },
    {
      "name": "startsWith",
      "comment": "See if the second string starts with the first one.\n\n    startsWith \"the\" \"theory\" == True\n    startsWith \"ory\" \"theory\" == False",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      }
    },
    {
      "name": "toFloat",
      "comment": "Try to convert a string into a float, failing on improperly formatted strings.\n\n    toFloat \"123\" == Ok 123.0\n    toFloat \"-42\" == Ok -42.0\n    toFloat \"3.1\" == Ok 3.1\n    toFloat \"31a\" == Err \"could not convert string '31a' to a Float\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Result"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            },
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        }
      }
    },
    {
      "name": "toInt",
      "comment": "Try to convert a string into an int, failing on improperly formatted strings.\n\n    toInt \"123\" == Ok 123\n    toInt \"-42\" == Ok -42\n    toInt \"3.1\" == Err \"could not convert string '3.1' to an Int\"\n    toInt \"31a\" == Err \"could not convert string '31a' to an Int\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Result"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            },
            {
              "tag": "type",
              "name": "Int"
            }
          ]
        }
      }
    },
    {
      "name": "toList",
      "comment": "Convert a string to a list of characters.\n\n    toList \"abc\" == ['a','b','c']",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "Char"
            }
          ]
        }
      }
    },
    {
      "name": "toLower",
      "comment": "Convert a string to all lower case. Useful for case-insensitive comparisons.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "toUpper",
      "comment": "Convert a string to all upper case. Useful for case-insensitive comparisons\nand VIRTUAL YELLING.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "trim",
      "comment": "Get rid of whitespace on both sides of a string.\n\n    trim \"  hats  \\n\" == \"hats\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "trimLeft",
      "comment": "Get rid of whitespace on the left of a string.\n\n    trimLeft \"  hats  \\n\" == \"hats  \\n\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "trimRight",
      "comment": "Get rid of whitespace on the right of a string.\n\n    trimRight \"  hats  \\n\" == \"  hats\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "uncons",
      "comment": "Split a non-empty string into its head and tail. This lets you\npattern match on strings exactly as you would with lists.\n\n    uncons \"abc\" == Just ('a',\"bc\")\n    uncons \"\"    == Nothing",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Maybe"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Char"
                },
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "words",
      "comment": "Break a string into words, splitting on chunks of whitespace.\n\n    words \"How are \\t you? \\n Good?\" == [\"How\",\"are\",\"you?\",\"Good?\"]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        }
      }
    }
  ]
}
,
{
  "name": "Text",
  "comment": "A library for styling and displaying text. While the `String` library\nfocuses on representing and manipulating strings of character strings, the\n`Text` library focuses on how those strings should look on screen. It lets\nyou make text bold or italic, set the typeface, set the text size, etc.\n\n# Creating Text\n@docs fromString, empty, append, concat, join\n\n# Creating Elements\n\nEach of the following functions places `Text` into a box. The function you use\ndetermines the alignment of the text.\n\n@docs leftAligned, rightAligned, centered, justified\n\n# Links and Style\n@docs link, Style, style, defaultStyle, Line\n\n# Convenience Functions\n\nThere are two convenience functions for creating an `Element` which can be\nuseful when debugging or prototyping:\n\n@docs plainText, asText\n\nThere are also a bunch of functions to set parts of a `Style` individually:\n\n@docs typeface, monospace, height, color, bold, italic, line",
  "aliases": [
    {
      "name": "Style",
      "comment": "Represents all the ways you can style `Text`. If the `typeface` list is\nempty or the `height` is `Nothing`, the users will fall back on their browser's\ndefault settings. The following `Style` is black, 16 pixel tall, underlined, and\nTimes New Roman (assuming that typeface is available on the user's computer):\n\n    { typeface = [ \"Times New Roman\", \"serif\" ]\n    , height   = Just 16\n    , color    = black\n    , bold     = False\n    , italic   = False\n    , line     = Just Under\n    }",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "typeface",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            }
          ],
          [
            "height",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            }
          ],
          [
            "color",
            {
              "tag": "type",
              "name": "Color"
            }
          ],
          [
            "bold",
            {
              "tag": "type",
              "name": "Bool"
            }
          ],
          [
            "italic",
            {
              "tag": "type",
              "name": "Bool"
            }
          ],
          [
            "line",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "Maybe"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Line"
                }
              ]
            }
          ]
        ]
      }
    }
  ],
  "types": [
    {
      "name": "Line",
      "comment": "Styles for lines on text. This allows you to add an underline, an overline,\nor a strike out text:\n\n    line Under   (fromString \"underline\")\n    line Over    (fromString \"overline\")\n    line Through (fromString \"strike out\")",
      "args": [],
      "cases": [
        [
          "Under",
          []
        ],
        [
          "Over",
          []
        ],
        [
          "Through",
          []
        ]
      ]
    },
    {
      "name": "Text",
      "comment": "",
      "args": [],
      "cases": [
        [
          "Text",
          []
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "append",
      "comment": "Put two chunks of text together.\n\n    append (fromString \"hello \") (fromString \"world\") == fromString \"hello world\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Text"
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    },
    {
      "name": "asText",
      "comment": "Convert anything to its textual representation and make it displayable in\nthe browser. Excellent for debugging.\n\n    asText value = leftAligned (monospace (fromString (toString value)))",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "a"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "bold",
      "comment": "Make text bold.\n\n    fromString \"sometimes you want \" ++ bold (fromString \"emphasis\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "type",
          "name": "Text"
        }
      }
    },
    {
      "name": "centered",
      "comment": "Center text in the text block. There is equal spacing on either side of a\nline of text.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "color",
      "comment": "Set the color of some text.\n\n    color red (fromString \"Red\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Color"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Text"
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    },
    {
      "name": "concat",
      "comment": "Put many chunks of text together.\n\n    concat\n      [ fromString \"type \"\n      , bold (fromString \"Maybe\")\n      , fromString \" = Just a | Nothing\"\n      ]",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "Text"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Text"
        }
      }
    },
    {
      "name": "defaultStyle",
      "comment": "Plain black text. It uses the browsers default typeface and text height.\nNo decorations are used.\n\n    { typeface = []\n    , height = Nothing\n    , color = black\n    , bold = False\n    , italic = False\n    , line = Nothing\n    }",
      "type": {
        "tag": "type",
        "name": "Style"
      }
    },
    {
      "name": "empty",
      "comment": "Text with nothing in it.\n\n    empty = fromString \"\"",
      "type": {
        "tag": "type",
        "name": "Text"
      }
    },
    {
      "name": "fromString",
      "comment": "Convert a string into text which can be styled and displayed. To show the\nstring `\"Hello World!\"` on screen in italics, you could say:\n\n    main = leftAligned (italic (fromString \"Hello World!\"))",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "Text"
        }
      }
    },
    {
      "name": "height",
      "comment": "Set the height of some text.\n\n    height 40 (fromString \"Title\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Text"
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    },
    {
      "name": "italic",
      "comment": "Make text italic.\n\n    fromString \"make it \" ++ italic (fromString \"important\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "type",
          "name": "Text"
        }
      }
    },
    {
      "name": "join",
      "comment": "Put many chunks of text together with a separator.\n\n    chunks : List Text\n    chunks = List.map fromString [\"lions\",\"tigers\",\"bears\"]\n\n    join (fromString \", \") chunks == fromString \"lions, tigers, bears\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "Text"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    },
    {
      "name": "justified",
      "comment": "Align text along the left and right sides of the text block. Word spacing is\nadjusted to make this possible.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "leftAligned",
      "comment": "Align text along the left side of the text block. This is sometimes known as\n*ragged right*.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "line",
      "comment": "Put lines on text.\n\n    line Under   (fromString \"underlined\")\n    line Over    (fromString \"overlined\")\n    line Through (fromString \"strike out\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Line"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Text"
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    },
    {
      "name": "link",
      "comment": "Create a link by providing a URL and the text of the link.\n\n    link \"http://elm-lang.org\" (fromString \"Elm Website\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Text"
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    },
    {
      "name": "markdown",
      "comment": "for internal use only",
      "type": {
        "tag": "type",
        "name": "Element"
      }
    },
    {
      "name": "monospace",
      "comment": "Switch to a monospace typeface. Good for code snippets.\n\n    monospace (fromString \"foldl (+) 0 [1,2,3]\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "type",
          "name": "Text"
        }
      }
    },
    {
      "name": "plainText",
      "comment": "Display a string with no styling.\n\n    plainText string = leftAligned (fromString string)",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "rightAligned",
      "comment": "Align text along the right side of the text block. This is sometimes known\nas *ragged left*.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Text"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "style",
      "comment": "Set the style of some text. For example, if you design a `Style` called\n`footerStyle` that is specifically for the bottom of your page, you could apply\nit to text like this:\n\n    style footerStyle (fromString \"the old prince / 2007\")",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Style"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Text"
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    },
    {
      "name": "typeface",
      "comment": "Provide a list of preferred typefaces for some text.\n\n    [\"helvetica\",\"arial\",\"sans-serif\"]\n\nNot every browser has access to the same typefaces, so rendering will use the\nfirst typeface in the list that is found on the user's computer. If there are\nno matches, it will use their default typeface. This works the same as the CSS\nfont-family property.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Text"
          },
          "out": {
            "tag": "type",
            "name": "Text"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Time",
  "comment": "Library for working with time.\n\n# Units\n@docs Time, millisecond, second, minute, hour,\n      inMilliseconds, inSeconds, inMinutes, inHours\n\n# Tickers\n@docs fps, fpsWhen, every\n\n# Timing\n@docs timestamp, delay, since",
  "aliases": [
    {
      "name": "Time",
      "comment": "Type alias to make it clearer when you are working with time values.\nUsing the `Time` constants instead of raw numbers is very highly recommended.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Float"
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "delay",
      "comment": "Delay a signal by a certain amount of time. So `(delay second Mouse.clicks)`\nwill update one second later than any mouse click.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          }
        }
      }
    },
    {
      "name": "every",
      "comment": "Takes a time interval t. The resulting signal is the current time, updated\nevery t.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "type",
              "name": "Time"
            }
          ]
        }
      }
    },
    {
      "name": "fps",
      "comment": "Takes desired number of frames per second (fps). The resulting signal\ngives a sequence of time deltas as quickly as possible until it reaches\nthe desired FPS. A time delta is the time between the last frame and the\ncurrent frame.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "type",
              "name": "Time"
            }
          ]
        }
      }
    },
    {
      "name": "fpsWhen",
      "comment": "Same as the fps function, but you can turn it on and off. Allows you\nto do brief animations based on user input without major inefficiencies.\nThe first time delta after a pause is always zero, no matter how long\nthe pause was. This way summing the deltas will actually give the amount\nof time that the output signal has been running.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "var",
          "name": "number"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "type",
                "name": "Bool"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "type",
                "name": "Time"
              }
            ]
          }
        }
      }
    },
    {
      "name": "hour",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Time"
      }
    },
    {
      "name": "inHours",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "inMilliseconds",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "inMinutes",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "inSeconds",
      "comment": "",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "type",
          "name": "Float"
        }
      }
    },
    {
      "name": "millisecond",
      "comment": "Units of time, making it easier to specify things like a half-second\n`(500 * milliseconds)` without remembering Elm&rsquo;s underlying units of time.",
      "type": {
        "tag": "type",
        "name": "Time"
      }
    },
    {
      "name": "minute",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Time"
      }
    },
    {
      "name": "second",
      "comment": "",
      "type": {
        "tag": "type",
        "name": "Time"
      }
    },
    {
      "name": "since",
      "comment": "Takes a time `t` and any signal. The resulting boolean signal is true for\ntime `t` after every event on the input signal. So ``(second `since`\nMouse.clicks)`` would result in a signal that is true for one second after\neach mouse click and false otherwise.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Time"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "var",
                "name": "a"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "type",
                "name": "Bool"
              }
            ]
          }
        }
      }
    },
    {
      "name": "timestamp",
      "comment": "Add a timestamp to any signal. Timestamps increase monotonically. When you\ncreate `(timestamp Mouse.x)`, an initial timestamp is produced. The timestamp\nupdates whenever `Mouse.x` updates.\n\nTimestamp updates are tied to individual events, so\n`(timestamp Mouse.x)` and `(timestamp Mouse.y)` will always have the same\ntimestamp because they rely on the same underlying event (`Mouse.position`).",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Signal"
          },
          "args": [
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Time"
                },
                {
                  "tag": "var",
                  "name": "a"
                }
              ]
            }
          ]
        }
      }
    }
  ]
}
,
{
  "name": "Touch",
  "comment": "This is an early version of the touch library. It will likely grow to\ninclude gestures that would be useful for both games and web-pages.\n\n# Touches\n@docs Touch, touches\n\n# Gestures\n@docs taps",
  "aliases": [
    {
      "name": "Touch",
      "comment": "Every `Touch` has `xy` coordinates. It also has an identifier\n`id` to distinguish one touch from another.\n\nA touch also keeps info about the initial point and time of contact:\n`x0`, `y0`, and `t0`. This helps compute more complicated gestures\nlike taps, drags, and swipes which need to know about timing or direction.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "x",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "y",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "id",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "x0",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "y0",
            {
              "tag": "type",
              "name": "Int"
            }
          ],
          [
            "t0",
            {
              "tag": "type",
              "name": "Time"
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "taps",
      "comment": "The last position that was tapped. Default value is `{x=0,y=0}`.\nUpdates whenever the user taps the screen.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": [
              [
                "x",
                {
                  "tag": "type",
                  "name": "Int"
                }
              ],
              [
                "y",
                {
                  "tag": "type",
                  "name": "Int"
                }
              ]
            ]
          }
        ]
      }
    },
    {
      "name": "touches",
      "comment": "A list of ongoing touches.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "Touch"
              }
            ]
          }
        ]
      }
    }
  ]
}
,
{
  "name": "Trampoline",
  "comment": "A [trampoline](http://en.wikipedia.org/wiki/Tail-recursive_function#Through_trampolining)\nmakes it possible to recursively call a function without growing the stack.\n\nPopular JavaScript implementations do not perform any tail-call elimination, so\nrecursive functions can cause a stack overflow if they go too deep. Trampolines\npermit unbounded recursion despite limitations in JavaScript.\n\nThis strategy may create many intermediate closures, which is very expensive in\nJavaScript, so use this library only when it is essential that you recurse deeply.\n\n# Trampolines\n@docs trampoline, Trampoline",
  "aliases": [],
  "types": [
    {
      "name": "Trampoline",
      "comment": "A way to build computations that may be deeply recursive. We will take an\nexample of a tail-recursive function and rewrite it in a way that lets us use\na trampoline:\n\n    length : List a -\u003e Int\n    length list = length' 0 list\n\n    length' : Int -\u003e List a -\u003e Int\n    length' accum list =\n        case list of\n          []     -\u003e accum\n          hd::tl -\u003e length' (accum+1) tl\n\nThis finds the length of a list, but if the list is too long, it may cause a\nstack overflow. We can rewrite it as follows:\n\n    length : List a -\u003e Int\n    length list = trampoline (length' 0 list)\n\n    length' : Int -\u003e List a -\u003e Trampoline Int\n    length' accum list =\n        case list of\n          []     -\u003e Done accum\n          hd::tl -\u003e Continue (\\() -\u003e length' (accum+1) tl)\n\nNow it uses a trampoline and can recurse without growing the stack!",
      "args": [
        "a"
      ],
      "cases": [
        [
          "Done",
          [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        ],
        [
          "Continue",
          [
            {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "_Tuple0"
              },
              "out": {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "Trampoline"
                },
                "args": [
                  {
                    "tag": "var",
                    "name": "a"
                  }
                ]
              }
            }
          ]
        ]
      ]
    }
  ],
  "values": [
    {
      "name": "trampoline",
      "comment": "Evaluate a trampolined value in constant space.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Trampoline"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "var",
          "name": "a"
        }
      }
    }
  ]
}
,
{
  "name": "Transform2D",
  "comment": "A library for performing [2D matrix transformations][affine].\nIt is used primarily with the `groupTransform` function from `Graphics.Collage` and\nallows you to do things like rotation, scaling, translation, shearing, and reflection.\n\nNote that all the matrices in this library are 3x3 matrices of homogeneous\ncoordinates, used for [affine transformations][affine]. Since the bottom row as\nalways `0 0 1` in these matrices, it is omitted in the diagrams below.\n\n [affine]: http://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations\n\n# Transforms\n@docs identity, matrix, rotation, translation, scale, scaleX, scaleY\n\n# Multiplication\n@docs multiply",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "identity",
      "comment": "Create an identity transform. Transforming by the identity does\nnot change anything, but it can come in handy as a default or\nbase case.\n\n        / 1 0 0 \\\n        \\ 0 1 0 /",
      "type": {
        "tag": "type",
        "name": "Transform2D"
      }
    },
    {
      "name": "matrix",
      "comment": "Create a transformation matrix. This lets you create transforms\nsuch as scales, shears, reflections, and translations.\n\n    matrix a b c d x y\n\n        / a b x \\\n        \\ c d y /\n\nNote that `x` and `y` are the translation values.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Float"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Float"
              },
              "out": {
                "tag": "lambda",
                "in": {
                  "tag": "type",
                  "name": "Float"
                },
                "out": {
                  "tag": "lambda",
                  "in": {
                    "tag": "type",
                    "name": "Float"
                  },
                  "out": {
                    "tag": "type",
                    "name": "Transform2D"
                  }
                }
              }
            }
          }
        }
      }
    },
    {
      "name": "multiply",
      "comment": "Multiply two transforms together.\n\n    multiply m n\n\n        / ma mb mx \\     / na nb nx \\\n        | mc md my |  .  | nc nd ny |\n        \\  0  0  1 /     \\  0  0  1 /",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Transform2D"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Transform2D"
          },
          "out": {
            "tag": "type",
            "name": "Transform2D"
          }
        }
      }
    },
    {
      "name": "rotation",
      "comment": "Create a [rotation matrix](http://en.wikipedia.org/wiki/Rotation_matrix).\nGiven an angle t, it creates a counterclockwise rotation matrix:\n\n    rotation t\n\n        / cos t  -sin t  0 \\\n        \\ sin t   cos t  0 /",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Transform2D"
        }
      }
    },
    {
      "name": "scale",
      "comment": "Creates a transformation matrix for scaling by a all directions.\n\n    scale s\n\n      / s 0 0 \\\n      \\ 0 s 0 /",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Transform2D"
        }
      }
    },
    {
      "name": "scaleX",
      "comment": "Create a transformation for horizontal scaling.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Transform2D"
        }
      }
    },
    {
      "name": "scaleY",
      "comment": "Create a transformation for vertical scaling.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "type",
          "name": "Transform2D"
        }
      }
    },
    {
      "name": "translation",
      "comment": "Create a transformation matrix for translation.\n\n    translation x y\n\n        / 1 0 x \\\n        \\ 0 1 y /",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Float"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Transform2D"
          }
        }
      }
    }
  ]
}
,
{
  "name": "WebSocket",
  "comment": "A library for low latency HTTP communication. See the HTTP library for\nstandard requests like GET, POST, etc. The API of this library is likely to\nchange to make it more flexible.\n\n# Open a Connection\n@docs connect",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "connect",
      "comment": "Create a web-socket. The first argument is the URL of the desired\nweb-socket server. The input signal holds the outgoing messages,\nand the resulting signal contains the incoming ones.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              }
            ]
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Signal"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              }
            ]
          }
        }
      }
    }
  ]
}
,
{
  "name": "Window",
  "comment": "Provides information about the container that your Elm program lives in.\nWhen you embed Elm in a `\u003cdiv\u003e` it gives the dimensions of the container, not\nthe whole window.\n\n# Dimensions\n@docs dimensions, width, height",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "dimensions",
      "comment": "The current width and height of the window (i.e. the area viewable to the\nuser, not including scroll bars).",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "type",
                "name": "Int"
              },
              {
                "tag": "type",
                "name": "Int"
              }
            ]
          }
        ]
      }
    },
    {
      "name": "height",
      "comment": "The current height of the window.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Int"
          }
        ]
      }
    },
    {
      "name": "width",
      "comment": "The current width of the window.",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Signal"
        },
        "args": [
          {
            "tag": "type",
            "name": "Int"
          }
        ]
      }
    }
  ]
}

]